{
  "openapi": "3.1.0",
  "info": {
    "title": "Mixpeek API",
    "description": "This is the Mixpeek API, providing access to various endpoints for data processing and retrieval.",
    "termsOfService": "https://mixpeek.com/terms",
    "contact": {
      "name": "Mixpeek Support",
      "url": "https://mixpeek.com/contact",
      "email": "info@mixpeek.com"
    },
    "version": "0.81"
  },
  "servers": [
    {
      "url": "https://api.mixpeek.com"
    }
  ],
  "paths": {
    "/v1/private/organizations": {
      "post": {
        "tags": [
          "Organizations, Private - Unauthenticated (used to sync from propel)"
        ],
        "summary": "Create Organization Private",
        "description": "Create a new private organization.",
        "operationId": "create_organization",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateOrganizationRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/OrganizationModelResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/private/organizations/{organization_identifier}": {
      "get": {
        "tags": [
          "Organizations, Private - Unauthenticated (used to sync from propel)"
        ],
        "summary": "Get Organization Private",
        "description": "Get a private organization by ID or name.",
        "operationId": "get_organization",
        "parameters": [
          {
            "name": "organization_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Organization Identifier"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/OrganizationModelResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "patch": {
        "tags": [
          "Organizations, Private - Unauthenticated (used to sync from propel)"
        ],
        "summary": "Update Organization Private",
        "description": "Admin-only: update organization tier and/or rate limits.",
        "operationId": "update_organization",
        "parameters": [
          {
            "name": "organization_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Organization Identifier"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/OrganizationAdminUpdateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/OrganizationModelResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Organizations, Private - Unauthenticated (used to sync from propel)"
        ],
        "summary": "Delete Organization Private",
        "description": "Delete a private organization.",
        "operationId": "delete_organization",
        "parameters": [
          {
            "name": "organization_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Organization Identifier"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GenericDeleteResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/private/organizations/add-user": {
      "post": {
        "tags": [
          "Organizations, Private - Unauthenticated (used to sync from propel)"
        ],
        "summary": "Add User To Organization Private",
        "description": "Add a user to a private organization.",
        "operationId": "add_user_to_organization",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AddUserToOrganizationRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/OrganizationModelResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/health": {
      "get": {
        "tags": [
          "Health",
          "Health"
        ],
        "summary": "Healthcheck",
        "description": "Health check endpoint.",
        "operationId": "healthcheck_health",
        "parameters": [
          {
            "name": "deep",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false,
              "title": "Deep"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HealthCheckResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/collections/features/extractors": {
      "get": {
        "tags": [
          "Feature Extractors"
        ],
        "summary": "List Feature Extractors",
        "description": "List all available feature extractors grouped by category",
        "operationId": "list_feature_extractors",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/FeatureExtractorResponseModel"
                  },
                  "type": "array",
                  "title": "Response List Feature Extractors V1 Collections Features Extractors Get"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/v1/collections/features/extractors/{feature_extractor_id}": {
      "get": {
        "tags": [
          "Feature Extractors"
        ],
        "summary": "Get Feature Extractor by Name",
        "description": "Get detailed information about a specific feature extractor by its name",
        "operationId": "get_feature_extractor_by",
        "parameters": [
          {
            "name": "feature_extractor_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Feature Extractor Id"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FeatureExtractorResponseModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/collections": {
      "post": {
        "tags": [
          "Collections"
        ],
        "summary": "Create Collection",
        "description": "This endpoint allows you to create a new collection.",
        "operationId": "create_collection",
        "parameters": [
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateCollectionRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CollectionResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/collections/{collection_identifier}": {
      "get": {
        "tags": [
          "Collections"
        ],
        "summary": "Get Collection",
        "description": "This endpoint allows you to retrieve a collection by ID or name.",
        "operationId": "get_collection",
        "parameters": [
          {
            "name": "collection_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The ID or name of the collection to retrieve",
              "title": "Collection Identifier"
            },
            "description": "The ID or name of the collection to retrieve"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CollectionResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "patch": {
        "tags": [
          "Collections"
        ],
        "summary": "Update Collection",
        "description": "Update mutable collection fields (e.g., taxonomy_applications)",
        "operationId": "update_collection",
        "parameters": [
          {
            "name": "collection_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The ID or name of the collection to update",
              "title": "Collection Identifier"
            },
            "description": "The ID or name of the collection to update"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "additionalProperties": true,
                "title": "Updates"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CollectionResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Collections"
        ],
        "summary": "Delete Collection",
        "description": "This endpoint allows you to delete a collection by ID or name.",
        "operationId": "delete_collection",
        "parameters": [
          {
            "name": "collection_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The ID or name of the collection to delete",
              "title": "Collection Identifier"
            },
            "description": "The ID or name of the collection to delete"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "responses": {
          "204": {
            "description": "Successful Response"
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/collections/{collection_identifier}/features": {
      "get": {
        "tags": [
          "Collections"
        ],
        "summary": "Describe collection features",
        "description": "List feature addresses and metadata available in this collection",
        "operationId": "describe_collection_features",
        "parameters": [
          {
            "name": "collection_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The ID or name of the collection to describe",
              "title": "Collection Identifier"
            },
            "description": "The ID or name of the collection to describe"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DescribeCollectionFeaturesResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/collections/list": {
      "post": {
        "tags": [
          "Collections"
        ],
        "summary": "List Collections",
        "description": "This endpoint allows you to list collections.",
        "operationId": "list_collections",
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "title": "Limit",
              "type": "integer",
              "nullable": true
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "title": "Offset",
              "type": "integer",
              "nullable": true
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListCollectionsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListCollectionsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/collections/{collection_identifier}/documents/{document_id}": {
      "get": {
        "tags": [
          "Collection Documents"
        ],
        "summary": "Get a document by ID.",
        "description": "Get a document by ID.",
        "operationId": "get_document",
        "parameters": [
          {
            "name": "collection_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The ID of the collection.",
              "title": "Collection Identifier"
            },
            "description": "The ID of the collection."
          },
          {
            "name": "document_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The ID of the document to retrieve.",
              "title": "Document Id"
            },
            "description": "The ID of the document to retrieve."
          },
          {
            "name": "return_url",
            "in": "query",
            "required": false,
            "schema": {
              "default": false,
              "title": "Return Url",
              "type": "boolean",
              "nullable": true
            }
          },
          {
            "name": "return_vectors",
            "in": "query",
            "required": false,
            "schema": {
              "default": false,
              "title": "Return Vectors",
              "type": "boolean",
              "nullable": true
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DocumentResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "Collection Documents"
        ],
        "summary": "Update Document",
        "description": "Update a document by ID.",
        "operationId": "update_document",
        "parameters": [
          {
            "name": "collection_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The ID of the collection.",
              "title": "Collection Identifier"
            },
            "description": "The ID of the collection."
          },
          {
            "name": "document_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The ID of the document to update.",
              "title": "Document Id"
            },
            "description": "The ID of the document to update."
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DocumentUpdateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DocumentResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Collection Documents"
        ],
        "summary": "Delete a document by ID.",
        "description": "Delete a document by ID.",
        "operationId": "delete_document",
        "parameters": [
          {
            "name": "collection_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The ID of the collection.",
              "title": "Collection Identifier"
            },
            "description": "The ID of the collection."
          },
          {
            "name": "document_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The ID of the document to delete.",
              "title": "Document Id"
            },
            "description": "The ID of the document to delete."
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GenericDeleteResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/collections/{collection_identifier}/documents/list": {
      "post": {
        "tags": [
          "Collection Documents"
        ],
        "summary": "List documents.",
        "description": "List documents.",
        "operationId": "list_documents",
        "parameters": [
          {
            "name": "collection_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The ID of the collection to list documents from.",
              "title": "Collection Identifier"
            },
            "description": "The ID of the collection to list documents from."
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "title": "Limit",
              "type": "integer",
              "nullable": true
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "title": "Offset",
              "type": "integer",
              "nullable": true
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListDocumentsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListDocumentsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/collections/{collection_identifier}/documents": {
      "post": {
        "tags": [
          "Collection Documents"
        ],
        "summary": "Create a document.",
        "description": "Create a document by ID.",
        "operationId": "create_document",
        "parameters": [
          {
            "name": "collection_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The ID of the collection.",
              "title": "Collection Identifier"
            },
            "description": "The ID of the collection."
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DocumentCreateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DocumentResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/retrievers/stages": {
      "get": {
        "tags": [
          "Retriever Stages"
        ],
        "summary": "List available retriever stages",
        "description": "List available retriever stages.",
        "operationId": "list_stages_retrievers",
        "parameters": [
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RetrieverStageDefinition"
                  },
                  "title": "Response List Stages V1 Retrievers Stages Get"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/retrievers": {
      "post": {
        "tags": [
          "Retrievers"
        ],
        "summary": "Create Retriever",
        "description": "Create retriever.",
        "operationId": "create_retriever",
        "parameters": [
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateRetrieverRequest",
                "description": "The retriever creation request."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RetrieverModel-Output"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/retrievers/{retriever_identifier}": {
      "get": {
        "tags": [
          "Retrievers"
        ],
        "summary": "Get Retriever",
        "description": "Get retriever with optional expanded collection details.",
        "operationId": "get_retriever",
        "parameters": [
          {
            "name": "retriever_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The ID or name of the retriever.",
              "title": "Retriever Identifier"
            },
            "description": "The ID or name of the retriever."
          },
          {
            "name": "expand_collections",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false,
              "title": "Expand Collections"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RetrieverModel-Output"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Retrievers"
        ],
        "summary": "Delete Retriever",
        "description": "This endpoint allows you to delete a retriever by ID or name.",
        "operationId": "delete_retriever",
        "parameters": [
          {
            "name": "retriever_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The ID or name of the retriever.",
              "title": "Retriever Identifier"
            },
            "description": "The ID or name of the retriever."
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GenericDeleteResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/retrievers/{retriever_identifier}/execute": {
      "post": {
        "tags": [
          "Retrievers"
        ],
        "summary": "Execute Retriever",
        "description": "Execute retriever with caching support.",
        "operationId": "execute_retriever",
        "parameters": [
          {
            "name": "retriever_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The ID or name of the retriever.",
              "title": "Retriever Identifier"
            },
            "description": "The ID or name of the retriever."
          },
          {
            "name": "if-none-match",
            "in": "header",
            "required": false,
            "schema": {
              "description": "ETag for cache validation",
              "title": "If-None-Match",
              "type": "string",
              "nullable": true
            },
            "description": "ETag for cache validation"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RetrieverQueryRequest",
                "description": "The retriever query request."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RetrieverResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/retrievers/debug-inference": {
      "post": {
        "tags": [
          "Retrievers"
        ],
        "summary": "Debug Inference",
        "description": "Debug inference by directly calling the inference API.",
        "operationId": "debug_inference_retrievers",
        "parameters": [
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/InferenceRequest",
                "description": "The inference request."
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DebugInferenceResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/retrievers/list": {
      "post": {
        "tags": [
          "Retrievers"
        ],
        "summary": "List Retrievers",
        "description": "This endpoint allows you to list retrievers.",
        "operationId": "list_retrievers",
        "parameters": [
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "description": "The list retrievers request.",
                "title": "List Request",
                "$ref": "#/components/schemas/ListRetrieversRequest",
                "nullable": true
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListRetrieversResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/organizations": {
      "get": {
        "tags": [
          "Organizations"
        ],
        "summary": "Get Organization",
        "description": "Get an organization.",
        "operationId": "get_organization",
        "parameters": [
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/OrganizationModelResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/organizations/users/{user_email}": {
      "get": {
        "tags": [
          "Organizations"
        ],
        "summary": "Get User",
        "description": "Get a user.",
        "operationId": "get_user_organizations_email",
        "parameters": [
          {
            "name": "user_email",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "User Email"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserModel-Output"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Organizations"
        ],
        "summary": "Delete User",
        "description": "Delete a user.",
        "operationId": "delete_user_organizations_email",
        "parameters": [
          {
            "name": "user_email",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "User Email"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GenericSuccessResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/organizations/users/{user_email}/api-keys": {
      "post": {
        "tags": [
          "Organizations"
        ],
        "summary": "Create Api Key",
        "description": "Create a new API key for a specific user.",
        "operationId": "create_key_organizations_users_email",
        "parameters": [
          {
            "name": "user_email",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "User Email"
            }
          },
          {
            "name": "key_name",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "default": "default",
              "title": "Key Name"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/APIKey"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/organizations/users/{user_email}/api-keys/{key_name}": {
      "delete": {
        "tags": [
          "Organizations"
        ],
        "summary": "Delete Api Key",
        "description": "Delete a specific API key for a user.",
        "operationId": "delete_key_organizations_users_email_name",
        "parameters": [
          {
            "name": "user_email",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "User Email"
            }
          },
          {
            "name": "key_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Key Name"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GenericSuccessResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "patch": {
        "tags": [
          "Organizations"
        ],
        "summary": "Update Api Key",
        "description": "Update an API key's name or permissions.",
        "operationId": "update_key_organizations_users_email_name",
        "parameters": [
          {
            "name": "user_email",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "User Email"
            }
          },
          {
            "name": "key_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Key Name"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/APIKeyUpdate"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/APIKey"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/namespaces": {
      "post": {
        "tags": [
          "Namespaces"
        ],
        "summary": "Create Namespace",
        "description": "Creates a new namespace with specified feature extractors and payload indexes.",
        "operationId": "create_namespace",
        "parameters": [
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateNamespaceRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NamespaceModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/namespaces/{namespace_identifier}": {
      "delete": {
        "tags": [
          "Namespaces"
        ],
        "summary": "Delete Namespace",
        "description": "Deletes an existing namespace using either its name or ID",
        "operationId": "delete_namespace",
        "parameters": [
          {
            "name": "namespace_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Either the namespace name or namespace ID",
              "examples": [
                "my_namespace",
                "ns_1234567890"
              ],
              "title": "Namespace Identifier"
            },
            "description": "Either the namespace name or namespace ID"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          }
        ],
        "responses": {
          "204": {
            "description": "Successful Response"
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "Namespaces"
        ],
        "summary": "Update Namespace",
        "description": "Fully updates an existing namespace (all fields required)",
        "operationId": "update_namespace",
        "parameters": [
          {
            "name": "namespace_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Either the namespace name or namespace ID",
              "examples": [
                "my_namespace",
                "ns_1234567890"
              ],
              "title": "Namespace Identifier"
            },
            "description": "Either the namespace name or namespace ID"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateNamespaceRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NamespaceModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "get": {
        "tags": [
          "Namespaces"
        ],
        "summary": "Get Namespace",
        "description": "Retrieve details of a specific namespace using either its name or ID",
        "operationId": "get_namespace",
        "parameters": [
          {
            "name": "namespace_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Either the namespace name or namespace ID",
              "examples": [
                "my_namespace",
                "ns_1234567890"
              ],
              "title": "Namespace Identifier"
            },
            "description": "Either the namespace name or namespace ID"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NamespaceModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/namespaces/list": {
      "post": {
        "tags": [
          "Namespaces"
        ],
        "summary": "List Namespaces",
        "description": "List all namespaces for a user",
        "operationId": "list_namespaces",
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "title": "Limit",
              "type": "integer",
              "nullable": true
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "title": "Offset",
              "type": "integer",
              "nullable": true
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListNamespacesRequest",
                "default": {
                  "case_sensitive": false
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListNamespacesResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/buckets": {
      "post": {
        "tags": [
          "Buckets"
        ],
        "summary": "Create Bucket",
        "description": "This endpoint allows you to create a new bucket with a defined schema.\n    A bucket is a collection of objects that conform to the schema.\n    The schema defines the structure and validation rules for objects in the bucket.",
        "operationId": "create_bucket",
        "parameters": [
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BucketCreateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BucketResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/buckets/{bucket_identifier}": {
      "get": {
        "tags": [
          "Buckets"
        ],
        "summary": "Get Bucket",
        "description": "This endpoint retrieves a bucket by its ID.",
        "operationId": "get_bucket",
        "parameters": [
          {
            "name": "bucket_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Bucket Identifier"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BucketResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "Buckets"
        ],
        "summary": "Update Bucket",
        "description": "This endpoint allows you to update an existing bucket.\n    You can update the bucket's name, description, and metadata.",
        "operationId": "update_bucket",
        "parameters": [
          {
            "name": "bucket_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Bucket Identifier"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BucketUpdateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BucketResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Buckets"
        ],
        "summary": "Delete Bucket",
        "description": "This endpoint deletes a bucket and all its objects.",
        "operationId": "delete_bucket",
        "parameters": [
          {
            "name": "bucket_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Bucket Identifier"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TaskResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/buckets/list": {
      "post": {
        "tags": [
          "Buckets"
        ],
        "summary": "List Buckets",
        "description": "This endpoint lists buckets with pagination, sorting, and filtering options.",
        "operationId": "list_buckets",
        "parameters": [
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListBucketsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListBucketsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/buckets/{bucket_identifier}/objects": {
      "post": {
        "tags": [
          "Bucket Objects"
        ],
        "summary": "Create Object",
        "description": "This endpoint creates a new object in the specified bucket.\n    The object must conform to the bucket's schema. It does not trigger processing.",
        "operationId": "create_object_buckets",
        "parameters": [
          {
            "name": "bucket_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique identifier of the bucket.",
              "title": "Bucket Identifier"
            },
            "description": "The unique identifier of the bucket."
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateObjectRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ObjectResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/buckets/{bucket_identifier}/objects/batch": {
      "post": {
        "tags": [
          "Bucket Objects"
        ],
        "summary": "Create Objects in Batch",
        "description": "This endpoint creates multiple new objects in the specified bucket as a batch.\n    Each object must conform to the bucket's schema. It does not trigger processing.",
        "operationId": "create_objects_batch_buckets",
        "parameters": [
          {
            "name": "bucket_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique identifier of the bucket.",
              "title": "Bucket Identifier"
            },
            "description": "The unique identifier of the bucket."
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateObjectsBatchRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ObjectResponse"
                  },
                  "title": "Response Create Objects Batch V1 Buckets  Bucket Identifier  Objects Batch Post"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/buckets/{bucket_identifier}/objects/{object_identifier}": {
      "get": {
        "tags": [
          "Bucket Objects"
        ],
        "summary": "Get Object",
        "description": "This endpoint retrieves an object by its ID from the specified bucket.",
        "operationId": "get_object_buckets",
        "parameters": [
          {
            "name": "bucket_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique identifier of the bucket.",
              "title": "Bucket Identifier"
            },
            "description": "The unique identifier of the bucket."
          },
          {
            "name": "object_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique identifier of the object.",
              "title": "Object Identifier"
            },
            "description": "The unique identifier of the object."
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ObjectResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "Bucket Objects"
        ],
        "summary": "Update Object",
        "description": "This endpoint updates an existing object in the specified bucket.\n    The updated object must conform to the bucket's schema. It does not trigger processing.",
        "operationId": "update_object_buckets",
        "parameters": [
          {
            "name": "bucket_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique identifier of the bucket.",
              "title": "Bucket Identifier"
            },
            "description": "The unique identifier of the bucket."
          },
          {
            "name": "object_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique identifier of the object.",
              "title": "Object Identifier"
            },
            "description": "The unique identifier of the object."
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateObjectRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ObjectResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Bucket Objects"
        ],
        "summary": "Delete Object",
        "description": "This endpoint deletes an object from the specified bucket.",
        "operationId": "delete_object_buckets",
        "parameters": [
          {
            "name": "bucket_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique identifier of the bucket.",
              "title": "Bucket Identifier"
            },
            "description": "The unique identifier of the bucket."
          },
          {
            "name": "object_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique identifier of the object.",
              "title": "Object Identifier"
            },
            "description": "The unique identifier of the object."
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "responses": {
          "204": {
            "description": "Successful Response"
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/buckets/{bucket_identifier}/objects/list": {
      "post": {
        "tags": [
          "Bucket Objects"
        ],
        "summary": "List Objects",
        "description": "This endpoint lists objects in a bucket with pagination.\n    Note: Filtering, sorting, and search capabilities will be added in a future update.",
        "operationId": "list_objects_buckets",
        "parameters": [
          {
            "name": "bucket_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique identifier of the bucket.",
              "title": "Bucket Identifier"
            },
            "description": "The unique identifier of the bucket."
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "title": "Limit",
              "type": "integer",
              "nullable": true
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "title": "Offset",
              "type": "integer",
              "nullable": true
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListObjectsResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/buckets/{bucket_identifier}/batches": {
      "post": {
        "tags": [
          "Bucket Batches"
        ],
        "summary": "Create Batch",
        "description": "Create a new batch for grouping bucket objects.",
        "operationId": "create_batch_buckets_batches",
        "parameters": [
          {
            "name": "bucket_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique identifier of the bucket.",
              "title": "Bucket Identifier"
            },
            "description": "The unique identifier of the bucket."
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateBatchRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/buckets/{bucket_identifier}/batches/{batch_id}/objects": {
      "post": {
        "tags": [
          "Bucket Batches"
        ],
        "summary": "Add Objects to Batch",
        "description": "Add objects to an existing batch. The batch must be in 'draft' status.",
        "operationId": "add_objects_to_batch_buckets_batches",
        "parameters": [
          {
            "name": "bucket_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique identifier of the bucket.",
              "title": "Bucket Identifier"
            },
            "description": "The unique identifier of the bucket."
          },
          {
            "name": "batch_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique identifier of the batch.",
              "title": "Batch Id"
            },
            "description": "The unique identifier of the batch."
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AddObjectsToBatchRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/buckets/{bucket_identifier}/batches/{batch_id}/submit": {
      "post": {
        "tags": [
          "Bucket Batches"
        ],
        "summary": "Submit Batch for Processing",
        "description": "Submit a batch for asynchronous processing. The batch must be in 'pending' status and contain objects.",
        "operationId": "submit_batch_buckets_batches",
        "parameters": [
          {
            "name": "bucket_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique identifier of the bucket.",
              "title": "Bucket Identifier"
            },
            "description": "The unique identifier of the bucket."
          },
          {
            "name": "batch_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique identifier of the batch.",
              "title": "Batch Id"
            },
            "description": "The unique identifier of the batch."
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TaskResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/buckets/{bucket_identifier}/batches/list": {
      "post": {
        "tags": [
          "Bucket Batches"
        ],
        "summary": "List Batches",
        "description": "List batches with pagination and filtering options.",
        "operationId": "list_batches_buckets",
        "parameters": [
          {
            "name": "bucket_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique identifier of the bucket.",
              "title": "Bucket Identifier"
            },
            "description": "The unique identifier of the bucket."
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListBatchesRequest",
                "default": {
                  "offset": 0,
                  "limit": 100
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListBatchesResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/buckets/{bucket_identifier}/batches/{batch_id}": {
      "delete": {
        "tags": [
          "Bucket Batches"
        ],
        "summary": "Delete Batch",
        "description": "Delete a batch by its ID.",
        "operationId": "delete_batch_buckets_batches",
        "parameters": [
          {
            "name": "bucket_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique identifier of the bucket.",
              "title": "Bucket Identifier"
            },
            "description": "The unique identifier of the bucket."
          },
          {
            "name": "batch_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique identifier of the batch.",
              "title": "Batch Id"
            },
            "description": "The unique identifier of the batch."
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GenericDeleteResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/buckets/{bucket_identifier}/batches/{batch_id}/cancel": {
      "post": {
        "tags": [
          "Bucket Batches"
        ],
        "summary": "Cancel Batch",
        "description": "Cancel a submitted/processing batch: cancels Ray job via engine and marks task/batch as CANCELLED.",
        "operationId": "cancel_batch_buckets_batches",
        "parameters": [
          {
            "name": "bucket_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique identifier of the bucket.",
              "title": "Bucket Identifier"
            },
            "description": "The unique identifier of the bucket."
          },
          {
            "name": "batch_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The unique identifier of the batch.",
              "title": "Batch Id"
            },
            "description": "The unique identifier of the batch."
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TaskResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/tasks/{task_id}": {
      "delete": {
        "tags": [
          "Tasks"
        ],
        "summary": "Kill Task",
        "description": "Kill a task.",
        "operationId": "kill_task",
        "parameters": [
          {
            "name": "task_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Task Id"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GenericDeleteResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "get": {
        "tags": [
          "Tasks"
        ],
        "summary": "Get Task Information",
        "description": "Retrieve a task by its ID.\n\n    A task may have an expiration time, after which it will still be returned but marked as expired.\n    This allows tracking of historical tasks while indicating their current validity state.",
        "operationId": "get_task",
        "parameters": [
          {
            "name": "task_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Task Id"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TaskResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/tasks/": {
      "get": {
        "tags": [
          "Tasks"
        ],
        "summary": "List Active Tasks",
        "description": "Retrieve all tasks that are not in a complete state (IN_PROGRESS, FAILED, CANCELED, or UNKNOWN)",
        "operationId": "list_active_tasks",
        "parameters": [
          {
            "name": "page",
            "in": "query",
            "required": false,
            "schema": {
              "default": 1,
              "title": "Page",
              "type": "integer",
              "nullable": true
            }
          },
          {
            "name": "page_size",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 10,
              "title": "Page Size"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListTasksResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/organizations/webhooks/": {
      "post": {
        "tags": [
          "Webhooks"
        ],
        "summary": "Create Webhook",
        "description": "Create a new webhook for the user's organization.",
        "operationId": "create_webhook_organizations",
        "parameters": [
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Webhook-Input"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Webhook-Output"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "get": {
        "tags": [
          "Webhooks"
        ],
        "summary": "List Webhooks",
        "description": "List all webhooks for the user's organization.",
        "operationId": "list_webhooks_organizations",
        "parameters": [
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Webhook-Output"
                  },
                  "title": "Response List Webhooks V1 Organizations Webhooks  Get"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/organizations/webhooks/{identifier}": {
      "get": {
        "tags": [
          "Webhooks"
        ],
        "summary": "Get Webhook",
        "description": "Get a single webhook by its ID.",
        "operationId": "get_webhook_organizations",
        "parameters": [
          {
            "name": "identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Identifier"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Webhook-Output"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "Webhooks"
        ],
        "summary": "Update Webhook",
        "description": "Update an existing webhook.",
        "operationId": "update_webhook_organizations",
        "parameters": [
          {
            "name": "identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Identifier"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Webhook-Input"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Webhook-Output"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Webhooks"
        ],
        "summary": "Delete Webhook",
        "description": "Delete a webhook.",
        "operationId": "delete_webhook_organizations",
        "parameters": [
          {
            "name": "identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Identifier"
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          }
        ],
        "responses": {
          "204": {
            "description": "Successful Response"
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/taxonomies": {
      "post": {
        "tags": [
          "Taxonomies"
        ],
        "summary": "Create Taxonomy",
        "description": "Create a taxonomy and return the created resource.",
        "operationId": "create_taxonomy_taxonomies",
        "parameters": [
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateTaxonomyRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TaxonomyResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/taxonomies/{taxonomy_identifier}": {
      "get": {
        "tags": [
          "Taxonomies"
        ],
        "summary": "Get Taxonomy",
        "description": "Get a taxonomy by ID or name.",
        "operationId": "get_taxonomy_taxonomies",
        "parameters": [
          {
            "name": "taxonomy_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Taxonomy ID or name",
              "title": "Taxonomy Identifier"
            },
            "description": "Taxonomy ID or name"
          },
          {
            "name": "version",
            "in": "query",
            "required": false,
            "schema": {
              "description": "Optional taxonomy version to fetch",
              "title": "Version",
              "type": "integer",
              "nullable": true
            },
            "description": "Optional taxonomy version to fetch"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TaxonomyResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Taxonomies"
        ],
        "summary": "Delete Taxonomy",
        "description": "Delete a taxonomy by ID or name.",
        "operationId": "delete_taxonomy_taxonomies",
        "parameters": [
          {
            "name": "taxonomy_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Taxonomy ID or name",
              "title": "Taxonomy Identifier"
            },
            "description": "Taxonomy ID or name"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GenericDeleteResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/taxonomies/{taxonomy_id}/versions": {
      "post": {
        "tags": [
          "Taxonomies"
        ],
        "summary": "Create Taxonomy Version",
        "description": "Create a new version for a taxonomy with a new config snapshot.",
        "operationId": "create_taxonomy_version_taxonomies",
        "parameters": [
          {
            "name": "taxonomy_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Taxonomy ID (tax_...)",
              "title": "Taxonomy Id"
            },
            "description": "Taxonomy ID (tax_...)"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "additionalProperties": true,
                "title": "Body"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TaxonomyResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "get": {
        "tags": [
          "Taxonomies"
        ],
        "summary": "List Taxonomy Versions",
        "description": "List all versions for a taxonomy (head included as latest).",
        "operationId": "list_taxonomy_versions_taxonomies",
        "parameters": [
          {
            "name": "taxonomy_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Taxonomy ID (tax_...)",
              "title": "Taxonomy Id"
            },
            "description": "Taxonomy ID (tax_...)"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListTaxonomiesResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/taxonomies/list": {
      "post": {
        "tags": [
          "Taxonomies"
        ],
        "summary": "List Taxonomies",
        "description": "List taxonomies with optional filters and pagination.",
        "operationId": "list_taxonomies",
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "title": "Limit",
              "type": "integer",
              "nullable": true
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "title": "Offset",
              "type": "integer",
              "nullable": true
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListTaxonomiesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListTaxonomiesResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/taxonomies/execute/{taxonomy_identifier}": {
      "post": {
        "tags": [
          "Taxonomies"
        ],
        "summary": "Execute Taxonomy",
        "description": "Execute on-demand taxonomy validation/testing.\n\nThis endpoint is for testing taxonomy configuration only.\nIt validates the taxonomy by calling the engine with empty documents.\n\nNOTE: Batch taxonomy materialization is NOT triggered via API.\nIt's automatically triggered by the engine after feature extraction,\nbased on collection configuration (taxonomy_applications).\n\nReal on-demand taxonomy enrichment happens within retriever pipelines.",
        "operationId": "execute_taxonomy_taxonomies",
        "parameters": [
          {
            "name": "taxonomy_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Taxonomy ID or name",
              "title": "Taxonomy Identifier"
            },
            "description": "Taxonomy ID or name"
          },
          {
            "name": "version",
            "in": "query",
            "required": false,
            "schema": {
              "description": "Optional taxonomy version to execute",
              "title": "Version",
              "type": "integer",
              "nullable": true
            },
            "description": "Optional taxonomy version to execute"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "anyOf": [
                  {
                    "$ref": "#/components/schemas/ExecuteTaxonomyRequest"
                  },
                  {
                    "type": "object",
                    "additionalProperties": true
                  }
                ],
                "title": "Payload"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/JoinResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/clusters": {
      "post": {
        "tags": [
          "Clusters"
        ],
        "summary": "Create Cluster",
        "description": "This endpoint allows you to create a new cluster configuration.",
        "operationId": "create_cluster",
        "parameters": [
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateClusterRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ClusterModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/clusters/execute": {
      "post": {
        "tags": [
          "Clusters"
        ],
        "summary": "Execute Clustering",
        "description": "Execute clustering on a collection using the specified algorithm and parameters.\n    This endpoint triggers real-time clustering computation on the engine.",
        "operationId": "execute_clustering_clusters",
        "parameters": [
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExecuteClusterRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExecuteClusterResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/clusters/{cluster_identifier}": {
      "get": {
        "tags": [
          "Clusters"
        ],
        "summary": "Get Cluster",
        "description": "This endpoint allows you to retrieve a cluster by ID or name.",
        "operationId": "get_cluster",
        "parameters": [
          {
            "name": "cluster_identifier",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Cluster ID or name",
              "title": "Cluster Identifier"
            },
            "description": "Cluster ID or name"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ClusterModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/clusters/{cluster_id}": {
      "delete": {
        "tags": [
          "Clusters"
        ],
        "summary": "Delete Cluster",
        "description": "This endpoint allows you to delete a cluster by ID.",
        "operationId": "delete_cluster",
        "parameters": [
          {
            "name": "cluster_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Cluster ID",
              "title": "Cluster Id"
            },
            "description": "Cluster ID"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "responses": {
          "204": {
            "description": "Successful Response"
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/clusters/list": {
      "post": {
        "tags": [
          "Clusters"
        ],
        "summary": "List Clusters",
        "description": "This endpoint allows you to list clusters.",
        "operationId": "list_clusters",
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "title": "Limit",
              "type": "integer",
              "nullable": true
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "title": "Offset",
              "type": "integer",
              "nullable": true
            }
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListClustersRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListClustersResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/clusters/{cluster_id}/data": {
      "post": {
        "tags": [
          "Clusters"
        ],
        "summary": "Stream Cluster Data",
        "description": "Stream cluster data from S3 parquet files.",
        "operationId": "stream_cluster_data",
        "parameters": [
          {
            "name": "cluster_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Cluster ID",
              "title": "Cluster Id"
            },
            "description": "Cluster ID"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ClusterDataRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ClusterDataResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/clusters/enrich": {
      "post": {
        "tags": [
          "Clusters"
        ],
        "summary": "Apply Cluster Enrichment",
        "description": "Apply clustering enrichments to a collection via engine.",
        "operationId": "apply_cluster_enrichment_enrich",
        "parameters": [
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ApplyClusterEnrichmentRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ClusteringEnrichmentResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/clusters/{cluster_id}/artifacts": {
      "get": {
        "tags": [
          "Clusters"
        ],
        "summary": "Get Cluster Artifacts",
        "operationId": "get_cluster_artifacts",
        "parameters": [
          {
            "name": "cluster_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Cluster ID",
              "title": "Cluster Id"
            },
            "description": "Cluster ID"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": true,
                  "title": "Response Get Cluster Artifacts V1 Clusters  Cluster Id  Artifacts Get"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/clusters/jobs/submit": {
      "post": {
        "tags": [
          "Clusters"
        ],
        "summary": "Submit Clustering Job",
        "description": "Submit an asynchronous clustering job processed by the engine poller.",
        "operationId": "submit_clustering_job_clusters",
        "parameters": [
          {
            "name": "cluster_id",
            "in": "query",
            "required": false,
            "schema": {
              "description": "Optional cluster_id to link job to cluster doc",
              "title": "Cluster Id",
              "type": "string",
              "nullable": true
            },
            "description": "Optional cluster_id to link job to cluster doc"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExecuteClusterRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TaskResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/clusters/triggers": {
      "post": {
        "tags": [
          "Cluster Triggers"
        ],
        "summary": "Create Cluster Trigger",
        "description": "Create a new trigger for automated cluster execution.\n\n    Supports multiple trigger types:\n    - **cron**: Execute at specific times using cron expressions\n    - **interval**: Execute at fixed intervals\n    - **event**: Execute when specific events occur (e.g., documents added)\n    - **conditional**: Execute when conditions are met (e.g., drift threshold)",
        "operationId": "create_trigger_clusters",
        "parameters": [
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateTriggerRequest"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TriggerModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/clusters/triggers/list": {
      "post": {
        "tags": [
          "Cluster Triggers"
        ],
        "summary": "List Cluster Triggers",
        "description": "List cluster triggers with filters and pagination.",
        "operationId": "list_triggers_clusters",
        "parameters": [
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ListTriggersRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListTriggersResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/clusters/triggers/{trigger_id}": {
      "get": {
        "tags": [
          "Cluster Triggers"
        ],
        "summary": "Get Cluster Trigger",
        "description": "Get a cluster trigger by ID.",
        "operationId": "get_trigger_clusters",
        "parameters": [
          {
            "name": "trigger_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Trigger ID",
              "title": "Trigger Id"
            },
            "description": "Trigger ID"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TriggerModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "patch": {
        "tags": [
          "Cluster Triggers"
        ],
        "summary": "Update Cluster Trigger",
        "description": "Update a cluster trigger.\n\n    Allowed updates:\n    - schedule_config: Modify trigger schedule\n    - description: Update description\n    - status: Change status (use pause/resume endpoints instead)\n\n    Not allowed:\n    - trigger_type: Must delete and recreate\n    - cluster_id: Immutable\n    - execution_config: Immutable",
        "operationId": "update_trigger_clusters",
        "parameters": [
          {
            "name": "trigger_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Trigger ID",
              "title": "Trigger Id"
            },
            "description": "Trigger ID"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateTriggerRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TriggerModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Cluster Triggers"
        ],
        "summary": "Delete Cluster Trigger",
        "description": "Delete a cluster trigger (soft delete).",
        "operationId": "delete_trigger_clusters",
        "parameters": [
          {
            "name": "trigger_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Trigger ID",
              "title": "Trigger Id"
            },
            "description": "Trigger ID"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "responses": {
          "204": {
            "description": "Successful Response"
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/clusters/triggers/{trigger_id}/pause": {
      "post": {
        "tags": [
          "Cluster Triggers"
        ],
        "summary": "Pause Cluster Trigger",
        "description": "Pause trigger execution. Paused triggers retain configuration but do not execute.",
        "operationId": "pause_trigger_clusters",
        "parameters": [
          {
            "name": "trigger_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Trigger ID",
              "title": "Trigger Id"
            },
            "description": "Trigger ID"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TriggerModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/clusters/triggers/{trigger_id}/resume": {
      "post": {
        "tags": [
          "Cluster Triggers"
        ],
        "summary": "Resume Cluster Trigger",
        "description": "Resume paused trigger. Next execution time is recalculated from current time.",
        "operationId": "resume_trigger_clusters",
        "parameters": [
          {
            "name": "trigger_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Trigger ID",
              "title": "Trigger Id"
            },
            "description": "Trigger ID"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TriggerModel"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/v1/clusters/triggers/{trigger_id}/history": {
      "post": {
        "tags": [
          "Cluster Triggers"
        ],
        "summary": "Get Trigger Execution History",
        "description": "Get execution history for a trigger with pagination.",
        "operationId": "get_trigger_history_clusters",
        "parameters": [
          {
            "name": "trigger_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Trigger ID",
              "title": "Trigger Id"
            },
            "description": "Trigger ID"
          },
          {
            "name": "Authorization",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'",
              "title": "Authorization",
              "type": "string",
              "nullable": true
            },
            "description": "Bearer token authentication using your API key. Format: 'Bearer your_api_key'. To get an API key, create an account at mixpeek.com/start and generate a key in your account settings. Example: 'Bearer sk_1234567890abcdef'"
          },
          {
            "name": "X-Namespace",
            "in": "header",
            "required": false,
            "schema": {
              "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint.",
              "title": "X-Namespace",
              "type": "string",
              "nullable": true
            },
            "description": "Optional namespace for data isolation. This can be a namespace name or namespace ID. Example: 'netflix_prod' or 'ns_1234567890'. To create a namespace, use the /namespaces endpoint."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TriggerHistoryRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TriggerHistoryResponse"
                }
              }
            }
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "APIKey": {
        "properties": {
          "key": {
            "type": "string",
            "title": "Key"
          },
          "name": {
            "type": "string",
            "title": "Name"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At"
          },
          "permissions": {
            "items": {
              "$ref": "#/components/schemas/Permission"
            },
            "type": "array",
            "title": "Permissions"
          }
        },
        "type": "object",
        "title": "APIKey",
        "description": "API Key."
      },
      "APIKeyUpdate": {
        "properties": {
          "name": {
            "title": "Name",
            "type": "string",
            "nullable": true
          },
          "permissions": {
            "title": "Permissions",
            "items": {
              "$ref": "#/components/schemas/Permission"
            },
            "type": "array",
            "nullable": true
          }
        },
        "type": "object",
        "title": "APIKeyUpdate",
        "description": "API Key Update."
      },
      "AccountTier": {
        "type": "string",
        "enum": [
          "free",
          "pro",
          "enterprise"
        ],
        "title": "AccountTier",
        "description": "Account tier."
      },
      "AddObjectsToBatchRequest": {
        "properties": {
          "object_ids": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "minItems": 1,
            "title": "Object Ids",
            "description": "A list of object IDs to add to the batch.",
            "examples": [
              [
                "object_789",
                "object_101"
              ]
            ]
          }
        },
        "type": "object",
        "required": [
          "object_ids"
        ],
        "title": "AddObjectsToBatchRequest",
        "description": "The request model for adding objects to an existing batch."
      },
      "AddUserToOrganizationRequest": {
        "properties": {
          "organization_identifier": {
            "type": "string",
            "title": "Organization Identifier"
          },
          "users": {
            "items": {
              "$ref": "#/components/schemas/UserModel-Input"
            },
            "type": "array",
            "title": "Users"
          },
          "metadata": {
            "additionalProperties": true,
            "type": "object",
            "title": "Metadata"
          }
        },
        "type": "object",
        "required": [
          "organization_identifier"
        ],
        "title": "AddUserToOrganizationRequest",
        "description": "Add User to Organization Request."
      },
      "AgglomerativeParams": {
        "properties": {
          "n_clusters": {
            "title": "N Clusters",
            "description": "Number of clusters to find. Can be None if distance_threshold is not None",
            "default": 2,
            "type": "integer",
            "minimum": 2.0,
            "nullable": true
          },
          "affinity": {
            "type": "string",
            "title": "Affinity",
            "description": "Metric used to compute linkage. Can be 'euclidean', 'l1', 'l2', 'manhattan', 'cosine', or 'precomputed'",
            "default": "euclidean"
          },
          "memory": {
            "title": "Memory",
            "description": "Path to the caching directory",
            "type": "string",
            "nullable": true
          },
          "connectivity": {
            "title": "Connectivity",
            "description": "Connectivity matrix. Defines which samples are neighbors",
            "nullable": true
          },
          "compute_full_tree": {
            "type": "string",
            "title": "Compute Full Tree",
            "description": "Whether to compute the full tree ('auto', True, or False)",
            "default": "auto"
          },
          "linkage": {
            "type": "string",
            "title": "Linkage",
            "description": "Linkage criterion ('ward', 'complete', 'average', 'single')",
            "default": "ward"
          },
          "distance_threshold": {
            "title": "Distance Threshold",
            "description": "The linkage distance threshold above which clusters will not be merged",
            "type": "number",
            "exclusiveMinimum": 0.0,
            "nullable": true
          },
          "compute_distances": {
            "type": "boolean",
            "title": "Compute Distances",
            "description": "Whether to compute distances between clusters",
            "default": false
          }
        },
        "type": "object",
        "title": "AgglomerativeParams",
        "description": "Parameters for Agglomerative clustering algorithm."
      },
      "ApplyClusterEnrichmentRequest": {
        "properties": {
          "clustering_ids": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Clustering Ids",
            "description": "Clustering result IDs to apply"
          },
          "source_collection_id": {
            "type": "string",
            "title": "Source Collection Id",
            "description": "Collection to enrich"
          },
          "target_collection_id": {
            "title": "Target Collection Id",
            "description": "Target collection to write enriched docs to",
            "type": "string",
            "nullable": true
          },
          "batch_size": {
            "type": "integer",
            "minimum": 1.0,
            "title": "Batch Size",
            "description": "Batch size for processing",
            "default": 1000
          },
          "parallelism": {
            "type": "integer",
            "minimum": 1.0,
            "title": "Parallelism",
            "description": "Parallel workers",
            "default": 1
          }
        },
        "type": "object",
        "required": [
          "clustering_ids",
          "source_collection_id"
        ],
        "title": "ApplyClusterEnrichmentRequest",
        "description": "Request to apply clustering enrichment to a collection.\n\nSupports applying multiple clustering results in one request via\n`clustering_ids`. For backward compatibility, a single `clustering_id`\nis also accepted and up-converted."
      },
      "AttributeBasedConfig": {
        "properties": {
          "attributes": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Attributes",
            "description": "Attributes to use for clustering"
          },
          "hierarchical_grouping": {
            "type": "boolean",
            "title": "Hierarchical Grouping",
            "description": "Whether to create hierarchical groups",
            "default": false
          },
          "aggregation_method": {
            "title": "Aggregation Method",
            "description": "Method for aggregating attributes",
            "type": "string",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "attributes"
        ],
        "title": "AttributeBasedConfig",
        "description": "Configuration for attribute-based clustering."
      },
      "BaseFeatureExtractorModel-Input": {
        "properties": {
          "feature_extractor_name": {
            "type": "string",
            "title": "Feature Extractor Name",
            "description": "Name of the feature extractor"
          },
          "version": {
            "type": "string",
            "title": "Version",
            "description": "Version of the feature extractor"
          }
        },
        "type": "object",
        "required": [
          "feature_extractor_name",
          "version"
        ],
        "title": "BaseFeatureExtractorModel",
        "description": "Minimum feature extractor definition."
      },
      "BaseFeatureExtractorModel-Output": {
        "properties": {
          "feature_extractor_name": {
            "type": "string",
            "title": "Feature Extractor Name",
            "description": "Name of the feature extractor"
          },
          "version": {
            "type": "string",
            "title": "Version",
            "description": "Version of the feature extractor"
          },
          "feature_extractor_id": {
            "type": "string",
            "title": "Feature Extractor Id",
            "description": "Construct unique identifier for the feature extractor instance (name + version).",
            "readOnly": true
          }
        },
        "type": "object",
        "required": [
          "feature_extractor_name",
          "version",
          "feature_extractor_id"
        ],
        "title": "BaseFeatureExtractorModel",
        "description": "Minimum feature extractor definition."
      },
      "BaseRateLimits": {
        "properties": {
          "default": {
            "type": "integer",
            "title": "Default",
            "default": 10
          },
          "search": {
            "type": "integer",
            "title": "Search",
            "default": 10
          },
          "upload": {
            "type": "integer",
            "title": "Upload",
            "default": 10
          },
          "delete": {
            "type": "integer",
            "title": "Delete",
            "default": 10
          }
        },
        "type": "object",
        "title": "BaseRateLimits",
        "description": "Base rate limits."
      },
      "BatchModel": {
        "properties": {
          "batch_id": {
            "type": "string",
            "title": "Batch Id",
            "description": "The unique identifier of the batch.",
            "examples": [
              "batch_123"
            ]
          },
          "bucket_id": {
            "type": "string",
            "title": "Bucket Id",
            "description": "The unique identifier of the bucket."
          },
          "status": {
            "$ref": "#/components/schemas/TaskStatusEnum",
            "description": "The current status of the batch.",
            "default": "DRAFT"
          },
          "object_ids": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Object Ids",
            "description": "A list of object IDs included in the batch.",
            "examples": [
              [
                "object_123",
                "object_456"
              ]
            ]
          },
          "collection_ids": {
            "title": "Collection Ids",
            "description": "A list of collection IDs that this batch is connected to for processing.",
            "examples": [
              [
                "col_123",
                "col_456"
              ]
            ],
            "items": {
              "type": "string"
            },
            "type": "array",
            "nullable": true
          },
          "error": {
            "title": "Error",
            "description": "The error message if the batch failed to process.",
            "examples": [
              "Failed to process batch: Object not found"
            ],
            "type": "string",
            "nullable": true
          },
          "type": {
            "$ref": "#/components/schemas/BatchType",
            "description": "The type of the batch.",
            "default": "BUCKET",
            "examples": [
              "BUCKET"
            ]
          },
          "manifest_key": {
            "title": "Manifest Key",
            "description": "The S3 manifest key for the batch.",
            "examples": [
              "s3://bucket/manifest.json"
            ],
            "type": "string",
            "nullable": true
          },
          "task_id": {
            "title": "Task Id",
            "description": "The task ID of the batch.",
            "examples": [
              "task_123"
            ],
            "type": "string",
            "nullable": true
          },
          "loaded_object_ids": {
            "title": "Loaded Object Ids",
            "description": "A list of object IDs that were successfully loaded into the batch.",
            "items": {
              "type": "string"
            },
            "type": "array",
            "nullable": true
          },
          "internal_metadata": {
            "title": "Internal Metadata",
            "description": "Internal engine/job metadata (e.g., job_id for provider).",
            "additionalProperties": true,
            "type": "object",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "bucket_id"
        ],
        "title": "BatchModel",
        "description": "The base model for a batch."
      },
      "BatchStatistics": {
        "properties": {
          "total": {
            "type": "integer",
            "title": "Total",
            "description": "Total number of batches in this bucket",
            "default": 0
          },
          "active": {
            "type": "integer",
            "title": "Active",
            "description": "Number of batches that are not completed (DRAFT, PENDING, IN_PROGRESS, PROCESSING)",
            "default": 0
          },
          "completed": {
            "type": "integer",
            "title": "Completed",
            "description": "Number of completed batches",
            "default": 0
          },
          "failed": {
            "type": "integer",
            "title": "Failed",
            "description": "Number of failed batches",
            "default": 0
          }
        },
        "type": "object",
        "title": "BatchStatistics",
        "description": "Statistics about batches in a bucket."
      },
      "BatchType": {
        "type": "string",
        "enum": [
          "BUCKET",
          "COLLECTION"
        ],
        "title": "BatchType",
        "description": "The type of batch."
      },
      "BlobDetails": {
        "properties": {
          "filename": {
            "title": "Filename",
            "type": "string",
            "nullable": true
          },
          "size_bytes": {
            "title": "Size Bytes",
            "type": "integer",
            "nullable": true
          },
          "mime_type": {
            "title": "Mime Type",
            "type": "string",
            "nullable": true
          },
          "hash": {
            "title": "Hash",
            "type": "string",
            "nullable": true
          },
          "s3_object_key": {
            "title": "S3 Object Key",
            "type": "string",
            "nullable": true
          }
        },
        "type": "object",
        "title": "BlobDetails",
        "description": "File details for a bucket object, these are automatically generated by the system."
      },
      "BlobModel": {
        "properties": {
          "blob_id": {
            "type": "string",
            "title": "Blob Id",
            "description": "Unique identifier for the blob"
          },
          "property": {
            "type": "string",
            "title": "Property",
            "description": "Property name of the blob"
          },
          "key_prefix": {
            "title": "Key Prefix",
            "description": "Storage key/path of the blob, this will be used to retrieve the blob from the storage. It is similar to a file path. If not provided, it will be placed in the root of the bucket.",
            "type": "string",
            "nullable": true
          },
          "type": {
            "$ref": "#/components/schemas/BucketSchemaFieldType",
            "description": "The schema field type this blob corresponds to (e.g., IMAGE, PDF, DOCUMENT)"
          },
          "data": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 2083,
                "minLength": 1,
                "format": "uri"
              },
              {
                "type": "string"
              },
              {
                "type": "integer"
              },
              {
                "type": "number"
              },
              {
                "type": "boolean"
              },
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "items": {},
                "type": "array"
              }
            ],
            "title": "Data",
            "description": "Data for the blob",
            "nullable": true
          },
          "metadata": {
            "title": "Metadata",
            "description": "Metadata for the blob, this will only be applied to the documents that use this blob",
            "additionalProperties": true,
            "type": "object",
            "nullable": true
          },
          "details": {
            "$ref": "#/components/schemas/BlobDetails",
            "description": "Details of the blob"
          }
        },
        "type": "object",
        "required": [
          "property",
          "type",
          "data"
        ],
        "title": "BlobModel",
        "description": "Model for a blob within a bucket object."
      },
      "BlobURLRef": {
        "properties": {
          "field": {
            "type": "string",
            "title": "Field",
            "description": "Stable semantic label for the blob (e.g., 'thumbnail', 'source')."
          },
          "role": {
            "type": "string",
            "enum": [
              "source",
              "thumbnail",
              "artifact",
              "aux"
            ],
            "title": "Role",
            "description": "Semantic role of this blob",
            "default": "source"
          },
          "type": {
            "type": "string",
            "enum": [
              "video",
              "image",
              "audio",
              "text",
              "pdf",
              "other"
            ],
            "title": "Type",
            "description": "Schema/blob type",
            "default": "other"
          },
          "url": {
            "type": "string",
            "title": "Url",
            "description": "Canonical blob URL; s3:// URLs are presignable"
          },
          "object_key": {
            "title": "Object Key",
            "description": "S3 object key if available (no bucket prefix)",
            "type": "string",
            "nullable": true
          },
          "filename": {
            "title": "Filename",
            "description": "Leaf filename",
            "type": "string",
            "nullable": true
          },
          "size_bytes": {
            "title": "Size Bytes",
            "description": "Blob size in bytes",
            "type": "integer",
            "nullable": true
          },
          "content_type": {
            "title": "Content Type",
            "description": "MIME content type",
            "type": "string",
            "nullable": true
          },
          "checksum": {
            "title": "Checksum",
            "description": "Optional checksum",
            "type": "string",
            "nullable": true
          },
          "created_at": {
            "title": "Created At",
            "description": "Blob create time",
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "source_blob_id": {
            "title": "Source Blob Id",
            "description": "Cross-reference to source blob in Mongo lineage",
            "type": "string",
            "nullable": true
          },
          "presigned_url": {
            "title": "Presigned Url",
            "description": "Response-only presigned https URL",
            "type": "string",
            "minLength": 1,
            "format": "uri",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "field",
          "url"
        ],
        "title": "BlobURLRef",
        "description": "Reference to a document-related blob (thumbnails, sources, artifacts).\n\nDevEx guidelines:\n- field: Use a stable, semantic label such as \"thumbnail\", \"source\", or a domain term.\n  Avoid leaking internal paths like \"metadata.thumbnail[0]\"; indexing (e.g., per-chunk)\n  should be inferred from filenames or stored separately (e.g., ordinal) if needed.\n- role: Determines behavior/UX grouping (thumbnail|source|artifact|aux). Prefer using role for UI.\n- url: Canonical locator. s3:// URLs are presignable via API when return_url=true.\n- presigned_url: Response-only, set by API to a time-limited https link."
      },
      "BoolIndexParams": {
        "properties": {
          "type": {
            "type": "string",
            "title": "Type",
            "default": "bool"
          }
        },
        "type": "object",
        "title": "BoolIndexParams",
        "description": "Configuration for boolean index."
      },
      "BucketCreateRequest": {
        "properties": {
          "bucket_name": {
            "type": "string",
            "title": "Bucket Name",
            "description": "Human-readable name for the bucket"
          },
          "description": {
            "title": "Description",
            "description": "Description of the bucket",
            "type": "string",
            "nullable": true
          },
          "bucket_schema": {
            "description": "Schema definition for objects in this bucket. REQUIRED if you want collections to use input_mappings. Defines the custom fields your objects will have (blob properties, metadata structure, etc.)",
            "$ref": "#/components/schemas/BucketSchema-Input",
            "nullable": true
          },
          "metadata": {
            "additionalProperties": true,
            "type": "object",
            "title": "Metadata",
            "description": "Additional metadata for the bucket"
          }
        },
        "type": "object",
        "required": [
          "bucket_name"
        ],
        "title": "BucketCreateRequest",
        "description": "Request model for creating a new bucket.\n\nCRITICAL: Define a bucket_schema if you plan to create collections that process this bucket's data.\n\nThe bucket_schema tells the system what fields your objects will have, enabling:\n- Collections to map your data fields to feature extractors via input_mappings\n- Validation of object structure at upload time\n- Type-safe data pipelines from bucket \u2192 collection \u2192 retrieval\n\nWithout a bucket_schema, you can still store objects, but collections won't be able to\nuse input_mappings to reference your custom fields.",
        "examples": [
          {
            "bucket_name": "product_images",
            "bucket_schema": {
              "properties": {
                "image": {
                  "description": "Product image blob",
                  "type": "image"
                },
                "metadata": {
                  "description": "Product information",
                  "properties": {
                    "title": {
                      "type": "string"
                    },
                    "category": {
                      "type": "string"
                    },
                    "price": {
                      "type": "float"
                    }
                  },
                  "type": "object"
                }
              }
            },
            "description": "Product images with metadata for e-commerce",
            "metadata": {
              "department": "Sales",
              "region": "US"
            }
          },
          {
            "bucket_name": "video_content",
            "bucket_schema": {
              "properties": {
                "video": {
                  "description": "Main video file",
                  "type": "video"
                },
                "transcript": {
                  "description": "Video transcript text",
                  "type": "text"
                },
                "thumbnail": {
                  "description": "Video thumbnail",
                  "type": "image"
                },
                "metadata": {
                  "properties": {
                    "duration_seconds": {
                      "type": "integer"
                    },
                    "title": {
                      "type": "string"
                    },
                    "tags": {
                      "items": {
                        "type": "string"
                      },
                      "type": "array"
                    }
                  },
                  "type": "object"
                }
              }
            },
            "description": "Video files with transcripts and thumbnails",
            "metadata": {
              "content_type": "educational"
            }
          },
          {
            "bucket_name": "text_documents",
            "bucket_schema": {
              "properties": {
                "content": {
                  "description": "Main text content",
                  "type": "text"
                },
                "metadata": {
                  "properties": {
                    "title": {
                      "type": "string"
                    },
                    "author": {
                      "type": "string"
                    },
                    "published_date": {
                      "type": "datetime"
                    }
                  },
                  "type": "object"
                }
              }
            },
            "description": "Text documents for NLP processing"
          }
        ]
      },
      "BucketResponse": {
        "properties": {
          "bucket_id": {
            "type": "string",
            "title": "Bucket Id",
            "description": "Unique identifier for the bucket"
          },
          "bucket_name": {
            "type": "string",
            "title": "Bucket Name",
            "description": "Human-readable name for the bucket"
          },
          "description": {
            "title": "Description",
            "description": "Description of the bucket",
            "type": "string",
            "nullable": true
          },
          "bucket_schema": {
            "description": "Schema definition for objects in this bucket",
            "$ref": "#/components/schemas/BucketSchema-Output",
            "nullable": true
          },
          "metadata": {
            "additionalProperties": true,
            "type": "object",
            "title": "Metadata",
            "description": "Additional metadata for the bucket"
          },
          "object_count": {
            "type": "integer",
            "title": "Object Count",
            "description": "Number of objects in the bucket"
          },
          "total_size_bytes": {
            "type": "integer",
            "title": "Total Size Bytes",
            "description": "Total size of all objects in the bucket in bytes"
          },
          "created_at": {
            "title": "Created At",
            "description": "When the bucket was created",
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "updated_at": {
            "title": "Updated At",
            "description": "Last modification time of bucket metadata",
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "last_upload_at": {
            "title": "Last Upload At",
            "description": "When the last object was uploaded to this bucket",
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "status": {
            "$ref": "#/components/schemas/TaskStatusEnum",
            "description": "Bucket lifecycle status (ACTIVE, ARCHIVED, SUSPENDED, IN_PROGRESS for deleting)",
            "default": "ACTIVE"
          },
          "is_locked": {
            "type": "boolean",
            "title": "Is Locked",
            "description": "Whether the bucket is locked (read-only)",
            "default": false
          },
          "batch_stats": {
            "description": "Batch statistics for this bucket (calculated asynchronously, stored in DB)",
            "$ref": "#/components/schemas/BatchStatistics",
            "nullable": true
          },
          "storage_stats": {
            "description": "Storage statistics for this bucket (calculated asynchronously, stored in DB)",
            "$ref": "#/components/schemas/StorageStatistics",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "bucket_name",
          "object_count",
          "total_size_bytes"
        ],
        "title": "BucketResponse",
        "description": "Response model for bucket operations."
      },
      "BucketSchema-Input": {
        "properties": {
          "properties": {
            "additionalProperties": {
              "$ref": "#/components/schemas/BucketSchemaField-Input"
            },
            "type": "object",
            "title": "Properties"
          }
        },
        "additionalProperties": true,
        "type": "object",
        "required": [
          "properties"
        ],
        "title": "BucketSchema",
        "description": "Schema definition for bucket objects.\n\nIMPORTANT: The bucket schema defines what fields your bucket objects will have.\nThis schema is REQUIRED if you want to:\n1. Create collections that use input_mappings to process your bucket data\n2. Validate object structure before ingestion\n3. Enable type-safe data pipelines\n\nThe schema defines the custom fields that will be used in:\n- Blob properties (e.g., \"content\", \"thumbnail\", \"transcript\")\n- Object metadata structure\n- Blob data structures\n\nExample workflow:\n1. Create bucket WITH schema defining your data structure\n2. Upload objects that conform to that schema\n3. Create collections that map schema fields to feature extractors\n\nWithout a bucket_schema, collections cannot use input_mappings."
      },
      "BucketSchema-Output": {
        "properties": {
          "properties": {
            "additionalProperties": {
              "$ref": "#/components/schemas/BucketSchemaField-Output"
            },
            "type": "object",
            "title": "Properties"
          }
        },
        "additionalProperties": true,
        "type": "object",
        "required": [
          "properties"
        ],
        "title": "BucketSchema",
        "description": "Schema definition for bucket objects.\n\nIMPORTANT: The bucket schema defines what fields your bucket objects will have.\nThis schema is REQUIRED if you want to:\n1. Create collections that use input_mappings to process your bucket data\n2. Validate object structure before ingestion\n3. Enable type-safe data pipelines\n\nThe schema defines the custom fields that will be used in:\n- Blob properties (e.g., \"content\", \"thumbnail\", \"transcript\")\n- Object metadata structure\n- Blob data structures\n\nExample workflow:\n1. Create bucket WITH schema defining your data structure\n2. Upload objects that conform to that schema\n3. Create collections that map schema fields to feature extractors\n\nWithout a bucket_schema, collections cannot use input_mappings."
      },
      "BucketSchemaField-Input": {
        "properties": {
          "type": {
            "$ref": "#/components/schemas/BucketSchemaFieldType"
          },
          "default": {
            "title": "Default",
            "nullable": true
          },
          "items": {
            "$ref": "#/components/schemas/BucketSchemaField-Input",
            "nullable": true
          },
          "properties": {
            "title": "Properties",
            "additionalProperties": {
              "$ref": "#/components/schemas/BucketSchemaField-Input"
            },
            "type": "object",
            "nullable": true
          },
          "example": {
            "title": "Example",
            "nullable": true
          },
          "description": {
            "title": "Description",
            "type": "string",
            "nullable": true
          },
          "enum": {
            "title": "Enum",
            "items": {},
            "type": "array",
            "nullable": true
          },
          "required": {
            "title": "Required",
            "default": false,
            "type": "boolean",
            "nullable": true
          }
        },
        "additionalProperties": true,
        "type": "object",
        "required": [
          "type"
        ],
        "title": "BucketSchemaField",
        "description": "Schema field definition for bucket objects."
      },
      "BucketSchemaField-Output": {
        "properties": {
          "type": {
            "$ref": "#/components/schemas/BucketSchemaFieldType"
          },
          "default": {
            "title": "Default",
            "nullable": true
          },
          "items": {
            "$ref": "#/components/schemas/BucketSchemaField-Output",
            "nullable": true
          },
          "properties": {
            "title": "Properties",
            "additionalProperties": {
              "$ref": "#/components/schemas/BucketSchemaField-Output"
            },
            "type": "object",
            "nullable": true
          },
          "example": {
            "title": "Example",
            "nullable": true
          },
          "description": {
            "title": "Description",
            "type": "string",
            "nullable": true
          },
          "enum": {
            "title": "Enum",
            "items": {},
            "type": "array",
            "nullable": true
          },
          "required": {
            "title": "Required",
            "default": false,
            "type": "boolean",
            "nullable": true
          }
        },
        "additionalProperties": true,
        "type": "object",
        "required": [
          "type"
        ],
        "title": "BucketSchemaField",
        "description": "Schema field definition for bucket objects."
      },
      "BucketSchemaFieldType": {
        "type": "string",
        "enum": [
          "string",
          "number",
          "integer",
          "float",
          "boolean",
          "object",
          "array",
          "date",
          "datetime",
          "json",
          "file",
          "text",
          "image",
          "audio",
          "video",
          "pdf",
          "document",
          "spreadsheet",
          "presentation",
          "dense_vector",
          "sparse_vector",
          "int8_vector"
        ],
        "title": "BucketSchemaFieldType",
        "description": "Enum for field types in bucket schemas."
      },
      "BucketUpdateRequest": {
        "properties": {
          "bucket_name": {
            "title": "Bucket Name",
            "description": "Human-readable name for the bucket",
            "type": "string",
            "nullable": true
          },
          "description": {
            "title": "Description",
            "description": "Description of the bucket",
            "type": "string",
            "nullable": true
          },
          "metadata": {
            "title": "Metadata",
            "description": "Additional metadata for the bucket",
            "additionalProperties": true,
            "type": "object",
            "nullable": true
          }
        },
        "type": "object",
        "title": "BucketUpdateRequest",
        "description": "Request model for updating an existing bucket."
      },
      "CacheConfig": {
        "properties": {
          "enabled": {
            "type": "boolean",
            "title": "Enabled",
            "description": "Whether caching is enabled for this retriever",
            "default": true
          },
          "ttl_seconds": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Ttl Seconds",
            "description": "Time-to-live for cached results in seconds. Default: 1 hour",
            "default": 3600
          },
          "stage": {
            "type": "string",
            "title": "Stage",
            "description": "Which stage to cache: 'retrieval', 'generation', or 'full'",
            "default": "retrieval"
          },
          "exclude_fields": {
            "title": "Exclude Fields",
            "description": "Fields to exclude from caching (e.g., PII fields)",
            "items": {
              "type": "string"
            },
            "type": "array",
            "nullable": true
          },
          "stats": {
            "description": "Cache performance statistics",
            "$ref": "#/components/schemas/CacheStatistics",
            "nullable": true
          }
        },
        "type": "object",
        "title": "CacheConfig",
        "description": "Configuration for retriever result caching.\n\nControls how retriever results are cached to improve performance\nand reduce redundant compute."
      },
      "CacheStatistics": {
        "properties": {
          "hit_count": {
            "type": "integer",
            "title": "Hit Count",
            "description": "Number of cache hits",
            "default": 0
          },
          "miss_count": {
            "type": "integer",
            "title": "Miss Count",
            "description": "Number of cache misses",
            "default": 0
          },
          "hit_rate": {
            "type": "number",
            "maximum": 1.0,
            "minimum": 0.0,
            "title": "Hit Rate",
            "description": "Cache hit rate (0.0 - 1.0)",
            "default": 0.0
          },
          "size_bytes": {
            "type": "integer",
            "title": "Size Bytes",
            "description": "Total size of cached data in bytes",
            "default": 0
          },
          "entry_count": {
            "type": "integer",
            "title": "Entry Count",
            "description": "Number of entries in cache",
            "default": 0
          },
          "last_invalidated_at": {
            "title": "Last Invalidated At",
            "description": "When the cache was last invalidated",
            "type": "string",
            "format": "date-time",
            "nullable": true
          }
        },
        "type": "object",
        "title": "CacheStatistics",
        "description": "Statistics about cache performance."
      },
      "ClusterCentroid": {
        "properties": {
          "cluster_id": {
            "type": "string",
            "title": "Cluster Id",
            "description": "Unique identifier for the cluster"
          },
          "centroid_vector": {
            "items": {
              "type": "number"
            },
            "type": "array",
            "title": "Centroid Vector",
            "description": "Feature vector representing the cluster center"
          },
          "feature_name": {
            "type": "string",
            "title": "Feature Name",
            "description": "Name of the feature this centroid represents"
          },
          "feature_dimensions": {
            "type": "integer",
            "title": "Feature Dimensions",
            "description": "Dimensionality of the feature vector"
          },
          "num_members": {
            "type": "integer",
            "title": "Num Members",
            "description": "Number of points in this cluster",
            "default": 0
          },
          "variance": {
            "title": "Variance",
            "description": "Variance/spread of the cluster",
            "type": "number",
            "nullable": true
          },
          "label": {
            "title": "Label",
            "description": "Human-readable label for the cluster",
            "type": "string",
            "nullable": true
          },
          "summary": {
            "title": "Summary",
            "description": "Brief summary of cluster contents",
            "type": "string",
            "nullable": true
          },
          "keywords": {
            "title": "Keywords",
            "description": "Keywords describing the cluster",
            "items": {
              "type": "string"
            },
            "type": "array",
            "nullable": true
          },
          "effective_features": {
            "additionalProperties": true,
            "type": "object",
            "title": "Effective Features",
            "description": "Aggregated features from cluster members"
          },
          "feature_statistics": {
            "additionalProperties": {
              "additionalProperties": {
                "type": "number"
              },
              "type": "object"
            },
            "type": "object",
            "title": "Feature Statistics",
            "description": "Statistics for each feature (mean, std, min, max)"
          },
          "parent_cluster_id": {
            "title": "Parent Cluster Id",
            "description": "Parent cluster for hierarchical clustering",
            "type": "string",
            "nullable": true
          },
          "child_cluster_ids": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Child Cluster Ids",
            "description": "Child clusters"
          },
          "hierarchy_level": {
            "type": "integer",
            "title": "Hierarchy Level",
            "description": "Level in hierarchy (0 = root)",
            "default": 0
          },
          "metadata": {
            "additionalProperties": true,
            "type": "object",
            "title": "Metadata",
            "description": "Additional cluster metadata"
          }
        },
        "type": "object",
        "required": [
          "cluster_id",
          "centroid_vector",
          "feature_name",
          "feature_dimensions"
        ],
        "title": "ClusterCentroid",
        "description": "Represents a cluster centroid with its feature vector and labels.",
        "examples": [
          {
            "centroid_vector": [
              0.1,
              0.2,
              0.3
            ],
            "cluster_id": "cluster_001",
            "feature_dimensions": 512,
            "num_members": 150,
            "variance": 0.05,
            "vector_name": "face_embedding"
          }
        ]
      },
      "ClusterCentroidData": {
        "properties": {
          "cluster_label": {
            "type": "string",
            "title": "Cluster Label",
            "description": "Cluster identifier/label"
          },
          "centroid_vector": {
            "items": {
              "type": "number"
            },
            "type": "array",
            "title": "Centroid Vector",
            "description": "Centroid feature vector"
          },
          "num_members": {
            "type": "integer",
            "title": "Num Members",
            "description": "Number of members in cluster"
          },
          "metadata": {
            "additionalProperties": true,
            "type": "object",
            "title": "Metadata",
            "description": "Additional metadata"
          }
        },
        "type": "object",
        "required": [
          "cluster_label",
          "centroid_vector",
          "num_members"
        ],
        "title": "ClusterCentroidData",
        "description": "Data for a single cluster centroid."
      },
      "ClusterDataRequest": {
        "properties": {
          "cluster_id": {
            "title": "Cluster Id",
            "description": "Cluster ID to fetch data for",
            "type": "string",
            "nullable": true
          },
          "include_centroids": {
            "type": "boolean",
            "title": "Include Centroids",
            "description": "Include cluster centroids",
            "default": true
          },
          "include_members": {
            "type": "boolean",
            "title": "Include Members",
            "description": "Include cluster members",
            "default": false
          },
          "limit": {
            "title": "Limit",
            "description": "Limit number of records",
            "type": "integer",
            "nullable": true
          },
          "offset": {
            "type": "integer",
            "title": "Offset",
            "description": "Offset for pagination",
            "default": 0
          }
        },
        "type": "object",
        "title": "ClusterDataRequest",
        "description": "Request to stream cluster data from parquet files.",
        "examples": [
          {
            "cluster_id": "cl_123",
            "include_centroids": true,
            "include_members": true,
            "limit": 100,
            "offset": 0
          }
        ]
      },
      "ClusterDataResponse": {
        "properties": {
          "cluster_id": {
            "type": "string",
            "title": "Cluster Id"
          },
          "centroids": {
            "items": {
              "$ref": "#/components/schemas/ClusterCentroidData"
            },
            "type": "array",
            "title": "Centroids"
          },
          "members": {
            "items": {
              "$ref": "#/components/schemas/ClusterMemberData"
            },
            "type": "array",
            "title": "Members"
          },
          "total_clusters": {
            "type": "integer",
            "title": "Total Clusters"
          },
          "total_members": {
            "type": "integer",
            "title": "Total Members"
          }
        },
        "type": "object",
        "required": [
          "cluster_id",
          "total_clusters",
          "total_members"
        ],
        "title": "ClusterDataResponse",
        "description": "Response with cluster data from parquet."
      },
      "ClusterMember": {
        "properties": {
          "document_id": {
            "type": "string",
            "title": "Document Id",
            "description": "ID of the document in the cluster"
          },
          "cluster_id": {
            "type": "string",
            "title": "Cluster Id",
            "description": "ID of the cluster this document belongs to"
          },
          "distance_to_centroid": {
            "type": "number",
            "title": "Distance To Centroid",
            "description": "Distance from document to cluster centroid"
          },
          "coordinates": {
            "items": {
              "type": "number"
            },
            "type": "array",
            "title": "Coordinates",
            "description": "Feature vector/coordinates of this document in the clustering space"
          },
          "source_details": {
            "$ref": "#/components/schemas/SourceDetails",
            "description": "Source information for the document"
          },
          "features": {
            "additionalProperties": true,
            "type": "object",
            "title": "Features",
            "description": "Additional features/metadata for this document"
          }
        },
        "type": "object",
        "required": [
          "document_id",
          "cluster_id",
          "distance_to_centroid",
          "coordinates",
          "source_details"
        ],
        "title": "ClusterMember",
        "description": "Represents a member of a cluster.",
        "examples": [
          {
            "cluster_id": "cluster_001",
            "coordinates": [
              0.12,
              0.23,
              0.34,
              0.45,
              0.56
            ],
            "distance_to_centroid": 0.15,
            "document_id": "doc_123",
            "features": {
              "category": "electronics",
              "product_name": "Widget A"
            },
            "source_details": {
              "source_id": "col_products_v1",
              "type": "collection"
            }
          }
        ]
      },
      "ClusterMemberData": {
        "properties": {
          "document_id": {
            "type": "string",
            "title": "Document Id",
            "description": "Document ID"
          },
          "cluster_label": {
            "type": "string",
            "title": "Cluster Label",
            "description": "Assigned cluster"
          },
          "distance_to_centroid": {
            "type": "number",
            "title": "Distance To Centroid",
            "description": "Distance to cluster center"
          },
          "coordinates": {
            "items": {
              "type": "number"
            },
            "type": "array",
            "title": "Coordinates",
            "description": "Feature vector/coordinates in clustering space"
          },
          "metadata": {
            "additionalProperties": true,
            "type": "object",
            "title": "Metadata",
            "description": "Document metadata"
          }
        },
        "type": "object",
        "required": [
          "document_id",
          "cluster_label",
          "distance_to_centroid",
          "coordinates"
        ],
        "title": "ClusterMemberData",
        "description": "Data for a cluster member."
      },
      "ClusterModel": {
        "properties": {
          "collection_ids": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "minItems": 1,
            "title": "Collection Ids",
            "description": "Collections to cluster together"
          },
          "cluster_name": {
            "title": "Cluster Name",
            "description": "Optional human-friendly name for the clustering job",
            "type": "string",
            "nullable": true
          },
          "cluster_type": {
            "$ref": "#/components/schemas/ClusterType",
            "description": "Vector or attribute clustering",
            "default": "vector"
          },
          "vector_config": {
            "description": "Required when cluster_type is 'vector'",
            "$ref": "#/components/schemas/VectorBasedConfig",
            "nullable": true
          },
          "attribute_config": {
            "description": "Required when cluster_type is 'attribute'",
            "$ref": "#/components/schemas/AttributeBasedConfig",
            "nullable": true
          },
          "llm_labeling": {
            "$ref": "#/components/schemas/LLMLabeling",
            "description": "Configuration for LLM-based cluster labeling"
          },
          "cluster_id": {
            "type": "string",
            "title": "Cluster Id",
            "description": "Unique cluster identifier"
          },
          "parquet_path": {
            "title": "Parquet Path",
            "description": "S3 path to parquet files with cluster data",
            "type": "string",
            "nullable": true
          },
          "members_key": {
            "title": "Members Key",
            "description": "S3 key to members.parquet (if saved)",
            "type": "string",
            "nullable": true
          },
          "num_clusters": {
            "title": "Num Clusters",
            "description": "Number of clusters found",
            "type": "integer",
            "nullable": true
          },
          "cluster_stats": {
            "description": "Clustering quality metrics",
            "$ref": "#/components/schemas/ClusterStats",
            "nullable": true
          },
          "status": {
            "$ref": "#/components/schemas/TaskStatusEnum",
            "description": "Clustering job status",
            "default": "PENDING"
          },
          "task_id": {
            "title": "Task Id",
            "description": "Associated task ID for clustering job",
            "type": "string",
            "nullable": true
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At",
            "description": "When the cluster was created"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Updated At",
            "description": "When the cluster was last updated"
          }
        },
        "type": "object",
        "required": [
          "collection_ids"
        ],
        "title": "ClusterModel",
        "description": "Cluster metadata stored in MongoDB.",
        "examples": [
          {
            "cluster_name": "products_clip_hdbscan",
            "cluster_type": "vector",
            "collection_ids": [
              "col_products_v1",
              "col_products_v2"
            ],
            "llm_labeling": {
              "enabled": true,
              "model_name": "gpt-4"
            },
            "vector_config": {
              "clustering_method": "hdbscan",
              "feature_extractor_name": "clip_vit_l_14",
              "hdbscan_parameters": {
                "min_cluster_size": 10,
                "min_samples": 5
              },
              "sample_size": 5000
            }
          },
          {
            "attribute_config": {
              "attributes": [
                "status"
              ],
              "hierarchical_grouping": true
            },
            "cluster_name": "orders_group_by_status",
            "cluster_type": "attribute",
            "collection_ids": [
              "col_orders_v1",
              "col_orders_v2",
              "col_orders_v3"
            ]
          }
        ]
      },
      "ClusterStats": {
        "properties": {
          "num_clusters": {
            "type": "integer",
            "title": "Num Clusters"
          },
          "noise_points": {
            "type": "integer",
            "title": "Noise Points"
          },
          "silhouette_score": {
            "type": "number",
            "title": "Silhouette Score"
          },
          "extra": {
            "additionalProperties": true,
            "type": "object",
            "title": "Extra"
          }
        },
        "type": "object",
        "required": [
          "num_clusters",
          "noise_points",
          "silhouette_score"
        ],
        "title": "ClusterStats",
        "description": "Basic clustering quality metrics."
      },
      "ClusterType": {
        "type": "string",
        "enum": [
          "vector",
          "attribute"
        ],
        "title": "ClusterType",
        "description": "Type of clustering to perform."
      },
      "ClusteringAlgorithm": {
        "type": "string",
        "enum": [
          "kmeans",
          "dbscan",
          "hdbscan",
          "agglomerative",
          "spectral",
          "gaussian_mixture",
          "mean_shift",
          "optics"
        ],
        "title": "ClusteringAlgorithm",
        "description": "Supported clustering algorithms."
      },
      "ClusteringConfig": {
        "properties": {
          "algorithm": {
            "$ref": "#/components/schemas/ClusteringAlgorithm",
            "description": "Clustering algorithm to use"
          },
          "algorithm_params": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/KMeansParams"
              },
              {
                "$ref": "#/components/schemas/DBSCANParams"
              },
              {
                "$ref": "#/components/schemas/HDBSCANParams"
              },
              {
                "$ref": "#/components/schemas/AgglomerativeParams"
              },
              {
                "$ref": "#/components/schemas/SpectralParams"
              },
              {
                "$ref": "#/components/schemas/GaussianMixtureParams"
              },
              {
                "$ref": "#/components/schemas/MeanShiftParams"
              },
              {
                "$ref": "#/components/schemas/OPTICSParams"
              },
              {
                "additionalProperties": true,
                "type": "object"
              }
            ],
            "title": "Algorithm Params",
            "description": "Algorithm-specific parameters",
            "nullable": true
          },
          "feature_vector": {
            "$ref": "#/components/schemas/FeatureVectorRef",
            "description": "Reference to the vector to use for clustering"
          },
          "additional_features": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Additional Features",
            "description": "Additional features for multi-modal clustering"
          },
          "normalize_features": {
            "type": "boolean",
            "title": "Normalize Features",
            "description": "Whether to normalize features before clustering",
            "default": true
          },
          "dimensionality_reduction": {
            "title": "Dimensionality Reduction",
            "description": "Optional dimensionality reduction prior to clustering",
            "oneOf": [
              {
                "$ref": "#/components/schemas/TSNEParams"
              },
              {
                "$ref": "#/components/schemas/UMAPParams"
              },
              {
                "$ref": "#/components/schemas/NoReduction"
              }
            ],
            "discriminator": {
              "propertyName": "method",
              "mapping": {
                "none": "#/components/schemas/NoReduction",
                "tsne": "#/components/schemas/TSNEParams",
                "umap": "#/components/schemas/UMAPParams"
              }
            },
            "nullable": true
          },
          "hierarchical": {
            "type": "boolean",
            "title": "Hierarchical",
            "description": "Whether to create hierarchical clusters",
            "default": false
          },
          "max_hierarchy_depth": {
            "type": "integer",
            "title": "Max Hierarchy Depth",
            "description": "Maximum depth for hierarchical clustering",
            "default": 3
          },
          "llm_labeling": {
            "description": "Configuration for LLM-based labeling",
            "$ref": "#/components/schemas/LLMLabeling",
            "nullable": true
          },
          "batch_size": {
            "type": "integer",
            "title": "Batch Size",
            "description": "Batch size for processing",
            "default": 1000
          },
          "parallelism": {
            "type": "integer",
            "title": "Parallelism",
            "description": "Number of parallel workers",
            "default": 4
          },
          "sample_size": {
            "title": "Sample Size",
            "description": "Sample size for large collections",
            "type": "integer",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "algorithm",
          "feature_vector"
        ],
        "title": "ClusteringConfig",
        "description": "Complete configuration for clustering operation."
      },
      "ClusteringEnrichmentResponse": {
        "properties": {
          "processed": {
            "type": "integer",
            "title": "Processed",
            "description": "Number of processed points"
          },
          "enriched": {
            "type": "integer",
            "title": "Enriched",
            "description": "Number of enriched points"
          },
          "failed": {
            "type": "integer",
            "title": "Failed",
            "description": "Number of failed points"
          },
          "batches": {
            "type": "integer",
            "title": "Batches",
            "description": "Batches processed"
          }
        },
        "type": "object",
        "required": [
          "processed",
          "enriched",
          "failed",
          "batches"
        ],
        "title": "ClusteringEnrichmentResponse",
        "description": "Response after applying clustering enrichment."
      },
      "CollectionDetail": {
        "properties": {
          "collection_id": {
            "type": "string",
            "title": "Collection Id",
            "description": "Collection identifier"
          },
          "collection_name": {
            "type": "string",
            "title": "Collection Name",
            "description": "Human-readable collection name"
          },
          "document_count": {
            "title": "Document Count",
            "description": "Number of documents in the collection",
            "type": "integer",
            "nullable": true
          },
          "enabled": {
            "title": "Enabled",
            "description": "Whether the collection is active",
            "type": "boolean",
            "nullable": true
          },
          "last_indexed_at": {
            "title": "Last Indexed At",
            "description": "When the collection was last indexed",
            "type": "string",
            "format": "date-time",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "collection_id",
          "collection_name"
        ],
        "title": "CollectionDetail",
        "description": "Detailed information about a collection referenced by a retriever."
      },
      "CollectionFeatureDescriptor": {
        "properties": {
          "feature_address": {
            "type": "string",
            "title": "Feature Address",
            "description": "Fully qualified feature address"
          },
          "feature_extractor_name": {
            "type": "string",
            "title": "Feature Extractor Name",
            "description": "Extractor name"
          },
          "version": {
            "type": "string",
            "title": "Version",
            "description": "Extractor version"
          },
          "vector_index": {
            "$ref": "#/components/schemas/VectorIndex",
            "description": "Vector index configuration (name, dimensions, type, distance, inference_name)"
          },
          "primary": {
            "type": "boolean",
            "title": "Primary",
            "description": "True if this is the primary output (short address allowed)",
            "default": false
          }
        },
        "type": "object",
        "required": [
          "feature_address",
          "feature_extractor_name",
          "version",
          "vector_index"
        ],
        "title": "CollectionFeatureDescriptor",
        "description": "Descriptor for a collection's available feature using existing models/keys."
      },
      "CollectionResponse": {
        "properties": {
          "collection_id": {
            "type": "string",
            "title": "Collection Id",
            "description": "Unique collection identifier"
          },
          "collection_name": {
            "type": "string",
            "title": "Collection Name",
            "description": "Collection name"
          },
          "description": {
            "title": "Description",
            "description": "Collection description",
            "type": "string",
            "nullable": true
          },
          "schema": {
            "title": "Schema",
            "description": "Collection schema",
            "additionalProperties": true,
            "type": "object",
            "nullable": true
          },
          "input_schema": {
            "description": "Input schema for the collection",
            "$ref": "#/components/schemas/BucketSchema-Output",
            "nullable": true
          },
          "output_schema": {
            "description": "Output schema after feature extraction",
            "$ref": "#/components/schemas/BucketSchema-Output",
            "nullable": true
          },
          "feature_extractors": {
            "items": {
              "$ref": "#/components/schemas/FeatureExtractorConfig-Output"
            },
            "type": "array",
            "title": "Feature Extractors",
            "description": "Feature extractors applied to this collection"
          },
          "source": {
            "$ref": "#/components/schemas/SourceConfig",
            "description": "Primary source configuration for this collection"
          },
          "source_lineage": {
            "items": {
              "$ref": "#/components/schemas/SingleLineageEntry"
            },
            "type": "array",
            "title": "Source Lineage",
            "description": "Lineage chain showing the processing history"
          },
          "vector_indexes": {
            "items": {},
            "type": "array",
            "title": "Vector Indexes",
            "description": "Vector indexes for this collection"
          },
          "payload_indexes": {
            "items": {},
            "type": "array",
            "title": "Payload Indexes",
            "description": "Payload indexes for this collection"
          },
          "enabled": {
            "type": "boolean",
            "title": "Enabled",
            "description": "Whether the collection is enabled",
            "default": true
          },
          "metadata": {
            "title": "Metadata",
            "description": "Additional metadata for the collection",
            "additionalProperties": true,
            "type": "object",
            "nullable": true
          },
          "taxonomy_applications": {
            "title": "Taxonomy Applications",
            "description": "List of taxonomies applied to this collection",
            "items": {
              "$ref": "#/components/schemas/TaxonomyApplicationConfig"
            },
            "type": "array",
            "nullable": true
          },
          "document_count": {
            "title": "Document Count",
            "description": "Number of documents in the collection",
            "type": "integer",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "collection_name",
          "source"
        ],
        "title": "CollectionResponse",
        "description": "Response model for collection endpoints.",
        "examples": [
          {
            "collection_name": "products",
            "description": "Product catalog",
            "taxonomy_applications": [
              {
                "execution_mode": "on_demand",
                "taxonomy_id": "tax_categories"
              },
              {
                "execution_mode": "materialize",
                "target_collection_id": "col_products_enriched",
                "taxonomy_id": "tax_brands"
              }
            ]
          }
        ]
      },
      "CreateBatchRequest": {
        "properties": {
          "object_ids": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "minItems": 1,
            "title": "Object Ids",
            "description": "A list of object IDs to add to the batch.",
            "examples": [
              [
                "object_789",
                "object_101"
              ]
            ]
          }
        },
        "type": "object",
        "required": [
          "object_ids"
        ],
        "title": "CreateBatchRequest",
        "description": "The request model for creating a new batch."
      },
      "CreateBlobRequest": {
        "properties": {
          "property": {
            "type": "string",
            "title": "Property",
            "description": "Property name in the schema that this blob belongs to"
          },
          "key_prefix": {
            "title": "Key Prefix",
            "description": "Optional prefix for the blob key",
            "type": "string",
            "nullable": true
          },
          "type": {
            "$ref": "#/components/schemas/BucketSchemaFieldType",
            "description": "The schema field type this blob corresponds to (e.g., IMAGE, PDF, DOCUMENT)"
          },
          "data": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 2083,
                "minLength": 1,
                "format": "uri"
              },
              {
                "type": "string"
              },
              {
                "type": "integer"
              },
              {
                "type": "number"
              },
              {
                "type": "boolean"
              },
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "items": {},
                "type": "array"
              }
            ],
            "title": "Data",
            "description": "Data for the blob, this will only be applied to the documents that use this blob",
            "nullable": true
          },
          "metadata": {
            "title": "Metadata",
            "description": "Metadata for the blob, this will only be applied to the documents that use this blob",
            "additionalProperties": true,
            "type": "object",
            "nullable": true
          },
          "canonicalize_source": {
            "title": "Canonicalize Source",
            "description": "If set, override object-level default to control source canonicalization for this blob.",
            "type": "boolean",
            "nullable": true
          },
          "force_remirror": {
            "title": "Force Remirror",
            "description": "If set, override object-level default to force re-upload even if an identical blob exists.",
            "type": "boolean",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "property",
          "type",
          "data"
        ],
        "title": "CreateBlobRequest",
        "description": "Request model for creating a new blob."
      },
      "CreateClusterRequest": {
        "properties": {
          "collection_ids": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "minItems": 1,
            "title": "Collection Ids",
            "description": "Collections to cluster together"
          },
          "cluster_name": {
            "title": "Cluster Name",
            "description": "Optional human-friendly name for the clustering job",
            "type": "string",
            "nullable": true
          },
          "cluster_type": {
            "$ref": "#/components/schemas/ClusterType",
            "description": "Vector or attribute clustering",
            "default": "vector"
          },
          "vector_config": {
            "description": "Required when cluster_type is 'vector'",
            "$ref": "#/components/schemas/VectorBasedConfig",
            "nullable": true
          },
          "attribute_config": {
            "description": "Required when cluster_type is 'attribute'",
            "$ref": "#/components/schemas/AttributeBasedConfig",
            "nullable": true
          },
          "llm_labeling": {
            "$ref": "#/components/schemas/LLMLabeling",
            "description": "Configuration for LLM-based cluster labeling"
          }
        },
        "type": "object",
        "required": [
          "collection_ids"
        ],
        "title": "CreateClusterRequest",
        "description": "Create a clustering job for one or more collections.",
        "examples": [
          {
            "cluster_name": "products_clip_hdbscan",
            "cluster_type": "vector",
            "collection_ids": [
              "col_products_v1",
              "col_products_v2"
            ],
            "llm_labeling": {
              "enabled": true,
              "model_name": "gpt-4"
            },
            "vector_config": {
              "clustering_method": "hdbscan",
              "feature_extractor_name": "clip_vit_l_14",
              "hdbscan_parameters": {
                "min_cluster_size": 10,
                "min_samples": 5
              },
              "sample_size": 5000
            }
          },
          {
            "attribute_config": {
              "attributes": [
                "status"
              ],
              "hierarchical_grouping": true
            },
            "cluster_name": "orders_group_by_status",
            "cluster_type": "attribute",
            "collection_ids": [
              "col_orders_v1",
              "col_orders_v2",
              "col_orders_v3"
            ]
          }
        ]
      },
      "CreateCollectionRequest": {
        "properties": {
          "collection_name": {
            "type": "string",
            "title": "Collection Name",
            "description": "Name of the collection to create"
          },
          "description": {
            "title": "Description",
            "description": "Description of the collection",
            "type": "string",
            "nullable": true
          },
          "source": {
            "$ref": "#/components/schemas/SourceConfig",
            "description": "Source configuration (bucket or collection) for this collection"
          },
          "input_schema": {
            "description": "Input schema for the collection. If not provided, inferred from source bucket's bucket_schema or source collection's output_schema. REQUIRED for input_mappings to work - defines what fields can be mapped to feature extractors.",
            "$ref": "#/components/schemas/BucketSchema-Input",
            "nullable": true
          },
          "feature_extractors": {
            "items": {
              "$ref": "#/components/schemas/FeatureExtractorConfig-Input"
            },
            "type": "array",
            "title": "Feature Extractors",
            "description": "Feature extractors to apply. Use input_mappings in each extractor to map source schema fields to extractor inputs. Example: {'image': 'product_image', 'text': 'metadata.title'}"
          },
          "enabled": {
            "type": "boolean",
            "title": "Enabled",
            "description": "Whether the collection is enabled",
            "default": true
          },
          "metadata": {
            "title": "Metadata",
            "description": "Additional metadata for the collection",
            "additionalProperties": true,
            "type": "object",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "collection_name",
          "source"
        ],
        "title": "CreateCollectionRequest",
        "description": "Request model for creating a new collection.\n\nCollections process data from buckets or other collections using feature extractors.\n\nCRITICAL: To use input_mappings in feature_extractors:\n1. Your source bucket MUST have a bucket_schema defined\n2. The input_mappings reference fields from that bucket_schema\n3. The system validates that mapped fields exist in the source schema\n\nExample workflow:\n1. Create bucket with schema: { \"properties\": { \"image\": {\"type\": \"image\"}, \"metadata\": {...} } }\n2. Upload objects conforming to that schema\n3. Create collection with input_mappings: { \"image\": \"image\", \"text\": \"metadata.title\" }\n4. The system validates \"image\" and \"metadata.title\" exist in the bucket schema\n\nWithout a bucket_schema, input_mappings will fail with:\n\"The source field 'X' does not exist in the source schema.\"",
        "examples": [
          {
            "collection_name": "product_embeddings",
            "description": "Generate embeddings from product images and titles",
            "enabled": true,
            "feature_extractors": [
              {
                "feature_extractor_id": "openai_clip_image",
                "input_mappings": {
                  "image": "image"
                },
                "parameters": {
                  "model": "clip-vit-base-patch32"
                }
              },
              {
                "feature_extractor_id": "openai_embed_text",
                "input_mappings": {
                  "text": "metadata.title"
                },
                "parameters": {
                  "model": "text-embedding-3-small"
                }
              }
            ],
            "source": {
              "bucket_id": "bkt_12345",
              "type": "bucket"
            }
          },
          {
            "collection_name": "video_analysis",
            "description": "Extract features from video content",
            "feature_extractors": [
              {
                "feature_extractor_id": "video_frame_extractor",
                "input_mappings": {
                  "video": "video"
                }
              },
              {
                "feature_extractor_id": "openai_embed_text",
                "input_mappings": {
                  "text": "transcript"
                }
              }
            ],
            "source": {
              "bucket_id": "bkt_video",
              "type": "bucket"
            }
          }
        ]
      },
      "CreateNamespaceRequest": {
        "properties": {
          "namespace_name": {
            "type": "string",
            "title": "Namespace Name",
            "description": "Name of the namespace to create",
            "example": "spotify_playlists_dev"
          },
          "description": {
            "title": "Description",
            "description": "Description of the namespace",
            "example": "This namespace contains playlists from Spotify",
            "type": "string",
            "nullable": true
          },
          "feature_extractors": {
            "items": {
              "$ref": "#/components/schemas/BaseFeatureExtractorModel-Input"
            },
            "type": "array",
            "minItems": 1,
            "title": "Feature Extractors",
            "description": "List of feature extractors to use. At least one feature extractor must be provided.",
            "example": [
              {
                "feature_extractor_id": "video_extractor_1.0.0",
                "feature_extractor_name": "video_extractor",
                "version": "1.0.0"
              }
            ]
          },
          "payload_indexes": {
            "title": "Payload Indexes",
            "description": "Optional list of custom payload index configurations. Indexes required by selected feature extractors will be added automatically.",
            "example": [
              {
                "field_name": "metadata.title",
                "field_schema": {
                  "lowercase": true,
                  "max_token_len": 15,
                  "min_token_len": 2,
                  "tokenizer": "word",
                  "type": "text"
                },
                "type": "text"
              },
              {
                "field_name": "metadata.description",
                "field_schema": {
                  "is_tenant": true,
                  "type": "keyword"
                },
                "type": "keyword"
              }
            ],
            "items": {
              "$ref": "#/components/schemas/PayloadIndexConfig-Input"
            },
            "type": "array",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "namespace_name",
          "feature_extractors"
        ],
        "title": "CreateNamespaceRequest",
        "description": "Request schema for creating a new namespace."
      },
      "CreateObjectRequest": {
        "properties": {
          "key_prefix": {
            "title": "Key Prefix",
            "description": "Storage key/path prefix of the object, this will be used to retrieve the object from the storage. It's at the root of the object.",
            "example": "/contract-2024",
            "type": "string",
            "nullable": true
          },
          "blobs": {
            "items": {
              "$ref": "#/components/schemas/CreateBlobRequest"
            },
            "type": "array",
            "title": "Blobs",
            "description": "List of blobs to be created in this object",
            "example": [
              {
                "data": {
                  "num_pages": 5,
                  "title": "Service Agreement 2024"
                },
                "key_prefix": "/content.pdf",
                "metadata": {
                  "author": "John Doe",
                  "department": "Legal"
                },
                "property": "content",
                "type": "PDF"
              }
            ]
          },
          "metadata": {
            "additionalProperties": true,
            "type": "object",
            "title": "Metadata",
            "description": "Additional metadata for the object, this will be appended in all downstream documents of the your connected collections.",
            "example": {
              "category": "contracts",
              "status": "draft",
              "year": 2024
            }
          },
          "skip_duplicates": {
            "type": "boolean",
            "title": "Skip Duplicates",
            "description": "Skip duplicate blobs, if a blob with the same hash already exists, it will be skipped.",
            "default": false
          },
          "canonicalize_source": {
            "type": "boolean",
            "title": "Canonicalize Source",
            "description": "Mirror non-S3 sources into internal S3 and reference canonically.",
            "default": true
          },
          "force_remirror": {
            "type": "boolean",
            "title": "Force Remirror",
            "description": "Force re-upload to S3 even if a blob with identical content already exists.",
            "default": false
          }
        },
        "type": "object",
        "title": "CreateObjectRequest",
        "description": "Request model for creating a bucket object.",
        "example": {
          "blobs": [
            {
              "data": {
                "num_pages": 5,
                "title": "Service Agreement 2024"
              },
              "key_prefix": "/contract-2024/content.pdf",
              "metadata": {
                "author": "John Doe",
                "department": "Legal"
              },
              "property": "content",
              "type": "json"
            },
            {
              "data": {
                "filename": "https://example.com/images/smartphone-x1.jpg",
                "mime_type": "image/jpeg"
              },
              "key_prefix": "/contract-2024/thumbnail.jpg",
              "metadata": {
                "height": 300,
                "width": 200
              },
              "property": "thumbnail",
              "type": "image"
            }
          ],
          "key_prefix": "/documents",
          "metadata": {
            "category": "contracts",
            "status": "draft",
            "year": 2024
          }
        }
      },
      "CreateObjectsBatchRequest": {
        "properties": {
          "objects": {
            "items": {
              "$ref": "#/components/schemas/CreateObjectRequest"
            },
            "type": "array",
            "title": "Objects",
            "description": "List of objects to be created in this batch."
          }
        },
        "type": "object",
        "required": [
          "objects"
        ],
        "title": "CreateObjectsBatchRequest",
        "description": "Request model for creating multiple bucket objects in a batch.",
        "examples": [
          {
            "objects": [
              {
                "blobs": [
                  {
                    "data": {
                      "num_pages": 5,
                      "title": "Service Agreement 2024"
                    },
                    "key_prefix": "/contract-2024/content.pdf",
                    "metadata": {
                      "author": "John Doe",
                      "department": "Legal"
                    },
                    "property": "content",
                    "type": "json"
                  }
                ],
                "key_prefix": "/documents",
                "metadata": {
                  "category": "contracts",
                  "status": "draft",
                  "year": 2024
                }
              }
            ]
          }
        ]
      },
      "CreateOrganizationRequest": {
        "properties": {
          "organization_name": {
            "type": "string",
            "title": "Organization Name"
          },
          "users": {
            "items": {
              "$ref": "#/components/schemas/UserModel-Input"
            },
            "type": "array",
            "title": "Users"
          },
          "metadata": {
            "additionalProperties": true,
            "type": "object",
            "title": "Metadata"
          }
        },
        "type": "object",
        "required": [
          "organization_name"
        ],
        "title": "CreateOrganizationRequest",
        "description": "Create Organization Request."
      },
      "CreateRetrieverRequest": {
        "properties": {
          "retriever_name": {
            "type": "string",
            "title": "Retriever Name",
            "description": "Human-readable retriever name",
            "examples": [
              "product_search_v1"
            ]
          },
          "description": {
            "title": "Description",
            "description": "Description of the retriever",
            "examples": [
              "CLIP + metadata prefiltering"
            ],
            "type": "string",
            "nullable": true
          },
          "input_schema": {
            "$ref": "#/components/schemas/RetrieverSchema-Input",
            "description": "Schema defining the expected input format"
          },
          "collection_ids": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Collection Ids",
            "description": "List of collection IDs to search in",
            "examples": [
              [
                "col_products_v1"
              ]
            ]
          },
          "stages": {
            "items": {
              "$ref": "#/components/schemas/StageInstanceConfig-Input"
            },
            "type": "array",
            "title": "Stages",
            "description": "List of stages to execute in order"
          },
          "metadata": {
            "additionalProperties": true,
            "type": "object",
            "title": "Metadata",
            "description": "Custom metadata for the retriever"
          },
          "tags": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Tags",
            "description": "Tags for organization and filtering"
          },
          "enabled": {
            "type": "boolean",
            "title": "Enabled",
            "description": "Whether the retriever should be enabled on creation",
            "default": true
          }
        },
        "type": "object",
        "required": [
          "retriever_name",
          "input_schema",
          "collection_ids",
          "stages"
        ],
        "title": "CreateRetrieverRequest",
        "description": "Request to create a new retriever."
      },
      "CreateTaxonomyRequest": {
        "properties": {
          "taxonomy_name": {
            "type": "string",
            "title": "Taxonomy Name",
            "description": "A unique name for the taxonomy within the namespace."
          },
          "description": {
            "title": "Description",
            "description": "An optional description of the taxonomy.",
            "type": "string",
            "nullable": true
          },
          "config": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/FlatTaxonomyConfig-Input"
              },
              {
                "$ref": "#/components/schemas/HierarchicalTaxonomyConfig-Input"
              }
            ],
            "title": "Config",
            "description": "Configuration specific to the taxonomy type.",
            "discriminator": {
              "propertyName": "taxonomy_type",
              "mapping": {
                "flat": "#/components/schemas/FlatTaxonomyConfig-Input",
                "hierarchical": "#/components/schemas/HierarchicalTaxonomyConfig-Input"
              }
            }
          }
        },
        "type": "object",
        "required": [
          "taxonomy_name",
          "config"
        ],
        "title": "CreateTaxonomyRequest",
        "description": "Request model to create a taxonomy.",
        "examples": [
          {
            "config": {
              "collection_id": "col_products_v1",
              "enrichment_fields": [
                {
                  "field_path": "metadata.tags",
                  "merge_mode": "append"
                }
              ],
              "input_mappings": [
                {
                  "input_key": "image_vector",
                  "path": "features.clip",
                  "source_type": "vector"
                }
              ],
              "retriever_id": "ret_clip_v1",
              "taxonomy_type": "flat"
            },
            "taxonomy_name": "product_tags"
          },
          {
            "config": {
              "hierarchy": {
                "col_executives_v1": "col_employees_v1"
              },
              "input_mappings": [
                {
                  "input_key": "face_vec",
                  "path": "features.face",
                  "source_type": "vector"
                }
              ],
              "retriever_id": "ret_face_v1",
              "taxonomy_type": "hierarchical"
            },
            "taxonomy_name": "org_hierarchy"
          }
        ]
      },
      "CreateTriggerRequest": {
        "properties": {
          "cluster_id": {
            "title": "Cluster Id",
            "description": "Optional existing cluster ID",
            "type": "string",
            "nullable": true
          },
          "execution_config": {
            "description": "Required if cluster_id not provided",
            "$ref": "#/components/schemas/TriggerExecutionConfig",
            "nullable": true
          },
          "trigger_type": {
            "$ref": "#/components/schemas/TriggerType",
            "description": "Type of trigger"
          },
          "schedule_config": {
            "additionalProperties": true,
            "type": "object",
            "title": "Schedule Config",
            "description": "Schedule configuration"
          },
          "description": {
            "title": "Description",
            "description": "Trigger description",
            "type": "string",
            "nullable": true
          },
          "status": {
            "$ref": "#/components/schemas/TriggerStatus",
            "description": "Initial status",
            "default": "active"
          }
        },
        "type": "object",
        "required": [
          "trigger_type",
          "schedule_config"
        ],
        "title": "CreateTriggerRequest",
        "description": "Request to create a new trigger."
      },
      "CreatorInfo": {
        "properties": {
          "user_id": {
            "type": "string",
            "title": "User Id",
            "description": "User identifier"
          },
          "email": {
            "title": "Email",
            "description": "User email address",
            "type": "string",
            "nullable": true
          },
          "name": {
            "title": "Name",
            "description": "User display name",
            "type": "string",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "user_id"
        ],
        "title": "CreatorInfo",
        "description": "Information about who created or updated a resource."
      },
      "DBSCANParams": {
        "properties": {
          "eps": {
            "type": "number",
            "exclusiveMinimum": 0.0,
            "title": "Eps",
            "description": "Maximum distance between two samples for one to be considered in the neighborhood of the other",
            "default": 0.5
          },
          "min_samples": {
            "type": "integer",
            "minimum": 1.0,
            "title": "Min Samples",
            "description": "Number of samples in a neighborhood for a point to be considered a core point",
            "default": 5
          },
          "metric": {
            "type": "string",
            "title": "Metric",
            "description": "Metric to use for distance computation",
            "default": "euclidean"
          },
          "metric_params": {
            "additionalProperties": true,
            "type": "object",
            "title": "Metric Params",
            "description": "Additional keyword arguments for the metric function"
          },
          "algorithm": {
            "type": "string",
            "title": "Algorithm",
            "description": "Algorithm to compute pointwise distances and find nearest neighbors ('auto', 'ball_tree', 'kd_tree', 'brute')",
            "default": "auto"
          },
          "leaf_size": {
            "type": "integer",
            "minimum": 1.0,
            "title": "Leaf Size",
            "description": "Leaf size passed to BallTree or KDTree",
            "default": 30
          },
          "p": {
            "type": "number",
            "exclusiveMinimum": 0.0,
            "title": "P",
            "description": "The power of the Minkowski metric to be used to calculate distance between points",
            "default": 2
          },
          "n_jobs": {
            "type": "integer",
            "title": "N Jobs",
            "description": "The number of parallel jobs to run (-1 means using all processors)",
            "default": 1
          }
        },
        "type": "object",
        "title": "DBSCANParams",
        "description": "Parameters for DBSCAN clustering algorithm."
      },
      "DatetimeIndexParams": {
        "properties": {
          "type": {
            "type": "string",
            "title": "Type",
            "default": "datetime"
          }
        },
        "type": "object",
        "title": "DatetimeIndexParams",
        "description": "Configuration for datetime index."
      },
      "DebugInferenceResponse": {
        "properties": {
          "inference_result": {
            "additionalProperties": true,
            "type": "object",
            "title": "Inference Result",
            "description": "The raw data returned by the inference API."
          },
          "debug_metadata": {
            "title": "Debug Metadata",
            "description": "Additional metadata for the debug call.",
            "additionalProperties": true,
            "type": "object",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "inference_result"
        ],
        "title": "DebugInferenceResponse",
        "description": "Response model for the debug inference endpoint."
      },
      "DenseVector": {
        "properties": {},
        "additionalProperties": true,
        "type": "object",
        "title": "DenseVector",
        "description": "Basic dense vector representation with flexible key naming.\n\nAccepts a single key-value pair where the key can be any string\nand the value must be a list of floats.\n\nExample:\n```json\n{\n    \"embedding\": [0.1, 0.2, 0.3, 0.4, 0.5]\n}\n```\nor\n```json\n{\n    \"my_custom_vector\": [0.1, 0.2, 0.3, 0.4, 0.5]\n}\n```"
      },
      "DescribeCollectionFeaturesResponse": {
        "properties": {
          "features": {
            "items": {
              "$ref": "#/components/schemas/CollectionFeatureDescriptor"
            },
            "type": "array",
            "title": "Features",
            "description": "Feature extractors and fields enabled on this collection"
          }
        },
        "type": "object",
        "required": [
          "features"
        ],
        "title": "DescribeCollectionFeaturesResponse",
        "examples": [
          {
            "features": [
              {
                "feature_extractor_name": "gte_modernbert_base",
                "inputs": [
                  {
                    "path": "text",
                    "type": "string"
                  }
                ],
                "outputs": [
                  {
                    "dim": 768,
                    "path": "features.text_embedding",
                    "type": "vector"
                  }
                ],
                "version": "1.0.0"
              }
            ]
          }
        ]
      },
      "DocumentCreateRequest": {
        "properties": {
          "collection_id": {
            "type": "string",
            "title": "Collection Id",
            "description": "ID of the collection the document belongs to.",
            "example": "collection_123"
          },
          "object_id": {
            "type": "string",
            "title": "Object Id",
            "description": "ID of the source object for this document."
          },
          "metadata": {
            "title": "Metadata",
            "description": "Arbitrary metadata for the document.",
            "additionalProperties": true,
            "type": "object",
            "nullable": true
          },
          "features": {
            "items": {
              "$ref": "#/components/schemas/FeatureModel"
            },
            "type": "array",
            "title": "Features",
            "description": "Features to associate with the document"
          }
        },
        "type": "object",
        "required": [
          "collection_id",
          "object_id"
        ],
        "title": "DocumentCreateRequest",
        "description": "Request model for creating a document."
      },
      "DocumentInputHandling": {
        "type": "string",
        "enum": [
          "individual",
          "grouped"
        ],
        "title": "DocumentInputHandling",
        "description": "How documents are provided to the feature extractor."
      },
      "DocumentOutputType": {
        "type": "string",
        "enum": [
          "single",
          "multiple"
        ],
        "title": "DocumentOutputType",
        "description": "Enum for document output types."
      },
      "DocumentResponse": {
        "properties": {
          "document_id": {
            "type": "string",
            "title": "Document Id",
            "description": "ID of the document"
          },
          "collection_id": {
            "type": "string",
            "title": "Collection Id",
            "description": "ID of the collection"
          },
          "object_id": {
            "type": "string",
            "title": "Object Id",
            "description": "ID of the source object for this document"
          },
          "enrichments": {
            "description": "Enrichments from clusters, taxonomies, joins, etc.",
            "$ref": "#/components/schemas/Enrichments",
            "nullable": true
          },
          "source_blobs": {
            "items": {
              "additionalProperties": true,
              "type": "object"
            },
            "type": "array",
            "title": "Source Blobs",
            "description": "A list of the source blobs for the object."
          },
          "internal_metadata": {
            "additionalProperties": true,
            "type": "object",
            "title": "Internal Metadata",
            "description": "Internal metadata calculated during processing."
          },
          "metadata": {
            "additionalProperties": true,
            "type": "object",
            "title": "Metadata",
            "description": "Metadata associated with the document"
          },
          "vector": {
            "title": "Vector",
            "description": "Vector embedding for the document",
            "items": {
              "type": "number"
            },
            "type": "array",
            "nullable": true
          },
          "presigned_url": {
            "title": "Presigned Url",
            "description": "Deprecated. Use 'presigned_urls' or document_blobs[*].presigned_url.",
            "type": "string",
            "nullable": true
          },
          "document_blobs": {
            "items": {
              "$ref": "#/components/schemas/BlobURLRef"
            },
            "type": "array",
            "title": "Document Blobs",
            "description": "Related blobs for this document (e.g., thumbnails, source). When return_url=true, each BlobURLRef.presigned_url will be populated alongside the canonical url."
          },
          "presigned_urls": {
            "items": {
              "$ref": "#/components/schemas/PresignedURLModel"
            },
            "type": "array",
            "title": "Presigned Urls",
            "description": "Aggregated presigned URLs keyed by logical name or filename."
          }
        },
        "additionalProperties": true,
        "type": "object",
        "required": [
          "document_id",
          "collection_id",
          "object_id"
        ],
        "title": "DocumentResponse",
        "description": "Response model for a single document."
      },
      "DocumentResult": {
        "properties": {
          "document_id": {
            "type": "string",
            "title": "Document Id",
            "description": "ID of the document"
          },
          "collection_id": {
            "title": "Collection Id",
            "description": "ID of the collection (optional in retriever outputs)",
            "type": "string",
            "nullable": true
          },
          "object_id": {
            "title": "Object Id",
            "description": "ID of the source object (optional in retriever outputs)",
            "type": "string",
            "nullable": true
          },
          "enrichments": {
            "$ref": "#/components/schemas/Enrichments",
            "description": "Enrichments from clusters, taxonomies, joins, etc."
          },
          "internal_metadata": {
            "additionalProperties": true,
            "type": "object",
            "title": "Internal Metadata",
            "description": "Internal metadata calculated during processing."
          },
          "metadata": {
            "additionalProperties": true,
            "type": "object",
            "title": "Metadata",
            "description": "Metadata associated with the document, user provided"
          },
          "source_blobs": {
            "items": {
              "additionalProperties": true,
              "type": "object"
            },
            "type": "array",
            "title": "Source Blobs",
            "description": "Blobs that constituted the original source object (lightweight)."
          },
          "document_blobs": {
            "items": {
              "$ref": "#/components/schemas/BlobURLRef"
            },
            "type": "array",
            "title": "Document Blobs",
            "description": "Related blobs (thumbnails, sources, artifacts) for this document. Each entry should use a stable field like 'thumbnail' or 'source' rather than dot-paths; chunk ordinals can be inferred from filenames or tracked separately."
          },
          "presigned_urls": {
            "items": {
              "$ref": "#/components/schemas/PresignedURLModel"
            },
            "type": "array",
            "title": "Presigned Urls",
            "description": "Aggregated presigned URL entries for related blobs. Populated by API when return_url=true."
          },
          "score": {
            "title": "Score",
            "description": "Relevance score of the document in the search results.",
            "type": "number",
            "nullable": true
          },
          "payload": {
            "additionalProperties": true,
            "type": "object",
            "title": "Payload",
            "description": "Raw provider payload (e.g., Qdrant hit payload)"
          }
        },
        "additionalProperties": true,
        "type": "object",
        "title": "DocumentResult",
        "description": "Represents a single document result from a retrieval operation.\n\nRetriever stages may not include full document lineage. To accommodate provider\npayloads, make certain fields optional and expose the raw provider payload."
      },
      "DocumentUpdateRequest": {
        "properties": {
          "metadata": {
            "title": "Metadata",
            "description": "New metadata for the document to update.",
            "additionalProperties": true,
            "type": "object",
            "nullable": true
          }
        },
        "additionalProperties": true,
        "type": "object",
        "title": "DocumentUpdateRequest",
        "description": "Request model for updating a document."
      },
      "DynamicValue": {
        "properties": {
          "type": {
            "type": "string",
            "const": "dynamic",
            "title": "Type",
            "default": "dynamic"
          },
          "field": {
            "type": "string",
            "title": "Field",
            "description": "The dot-notation path to the value in the runtime query request, e.g., 'inputs.user_id'",
            "examples": [
              "inputs.query_text",
              "filters.AND[0].value"
            ]
          }
        },
        "type": "object",
        "required": [
          "field"
        ],
        "title": "DynamicValue",
        "description": "A value that should be dynamically resolved from the query request."
      },
      "EmailConfig": {
        "properties": {
          "to_addresses": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "To Addresses",
            "description": "Email addresses to send to"
          },
          "subject_template": {
            "title": "Subject Template",
            "description": "Template for email subject",
            "type": "string",
            "nullable": true
          },
          "body_template": {
            "title": "Body Template",
            "description": "Template for email body",
            "type": "string",
            "nullable": true
          },
          "content_type": {
            "$ref": "#/components/schemas/NotificationContentType",
            "description": "Format of the email body",
            "default": "html"
          },
          "cc_addresses": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Cc Addresses",
            "description": "CC addresses"
          },
          "bcc_addresses": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Bcc Addresses",
            "description": "BCC addresses"
          }
        },
        "type": "object",
        "required": [
          "to_addresses"
        ],
        "title": "EmailConfig",
        "description": "Configuration for email notifications."
      },
      "EnrichmentField": {
        "properties": {
          "field_path": {
            "type": "string",
            "title": "Field Path",
            "description": "Dot-notation path of the field to copy from the taxonomy node."
          },
          "merge_mode": {
            "$ref": "#/components/schemas/EnrichmentMergeMode",
            "description": "Whether to overwrite the target's value or append (for arrays).",
            "default": "replace"
          }
        },
        "type": "object",
        "required": [
          "field_path"
        ],
        "title": "EnrichmentField",
        "description": "Field-level enrichment behaviour specification.",
        "examples": [
          {
            "field_path": "metadata.tags",
            "merge_mode": "append"
          },
          {
            "field_path": "category",
            "merge_mode": "replace"
          }
        ]
      },
      "EnrichmentMergeMode": {
        "type": "string",
        "enum": [
          "replace",
          "append"
        ],
        "title": "EnrichmentMergeMode",
        "description": "How a field from the taxonomy node should be merged into the target doc."
      },
      "Enrichments": {
        "properties": {
          "clusters": {
            "items": {
              "$ref": "#/components/schemas/ClusterMember"
            },
            "type": "array",
            "title": "Clusters",
            "description": "Cluster member assignments (reuses ClusterMember model)"
          },
          "taxonomies": {
            "items": {
              "$ref": "#/components/schemas/TaxonomyAssignment"
            },
            "type": "array",
            "title": "Taxonomies",
            "description": "Taxonomy assignments referencing taxonomy/node IDs"
          }
        },
        "type": "object",
        "title": "Enrichments",
        "description": "Container for document enrichments from various sources.\n\nUses existing models where appropriate to ensure consistency and reuse\n(e.g., `ClusterMember` for cluster assignments)."
      },
      "ErrorDetail": {
        "properties": {
          "message": {
            "type": "string",
            "title": "Message",
            "description": "Human-readable error message"
          },
          "type": {
            "type": "string",
            "title": "Type",
            "description": "Stable error type identifier (machine-readable)"
          },
          "details": {
            "title": "Details",
            "description": "Optional structured details to help debugging (validation errors, IDs, etc.)",
            "additionalProperties": true,
            "type": "object",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "message",
          "type"
        ],
        "title": "ErrorDetail",
        "description": "Error detail model."
      },
      "ErrorResponse": {
        "properties": {
          "success": {
            "type": "boolean",
            "title": "Success",
            "description": "Always false for error responses",
            "default": false
          },
          "status": {
            "type": "integer",
            "title": "Status",
            "description": "HTTP status code for this error"
          },
          "error": {
            "$ref": "#/components/schemas/ErrorDetail",
            "description": "Error details payload"
          }
        },
        "type": "object",
        "required": [
          "status",
          "error"
        ],
        "title": "ErrorResponse",
        "description": "Error response model.",
        "examples": [
          {
            "error": {
              "details": {
                "id": "ns_123",
                "resource": "namespace"
              },
              "message": "Namespace not found",
              "type": "NotFoundError"
            },
            "status": 404,
            "success": false
          }
        ]
      },
      "ExecuteClusterRequest": {
        "properties": {
          "collection_ids": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "minItems": 1,
            "title": "Collection Ids",
            "description": "IDs of the collections to cluster together"
          },
          "config": {
            "$ref": "#/components/schemas/ClusteringConfig",
            "description": "Clustering configuration including algorithm and parameters"
          },
          "sample_size": {
            "title": "Sample Size",
            "description": "Number of documents to sample for clustering",
            "type": "integer",
            "nullable": true
          },
          "store_results": {
            "type": "boolean",
            "title": "Store Results",
            "description": "Whether to store clustering results",
            "default": true
          },
          "include_members": {
            "type": "boolean",
            "title": "Include Members",
            "description": "Whether to include cluster membership in results",
            "default": false
          },
          "compute_metrics": {
            "type": "boolean",
            "title": "Compute Metrics",
            "description": "Whether to compute clustering quality metrics",
            "default": true
          },
          "save_artifacts": {
            "type": "boolean",
            "title": "Save Artifacts",
            "description": "Whether to save clustering artifacts (e.g., parquet) to S3",
            "default": false
          }
        },
        "type": "object",
        "required": [
          "collection_ids",
          "config"
        ],
        "title": "ExecuteClusterRequest",
        "description": "Request to execute clustering on one or more collections.",
        "examples": [
          {
            "collection_ids": [
              "col_products_v1",
              "col_products_v2"
            ],
            "compute_metrics": true,
            "config": {
              "algorithm": "kmeans",
              "algorithm_params": {
                "max_iter": 300,
                "n_clusters": 5
              },
              "feature_vector": {
                "vector_name": "text_extractor_v1_embedding"
              },
              "normalize_features": true
            },
            "include_members": false,
            "sample_size": 10000,
            "store_results": true
          }
        ]
      },
      "ExecuteClusterResponse": {
        "properties": {
          "success": {
            "type": "boolean",
            "title": "Success",
            "description": "Whether clustering was successful"
          },
          "run_id": {
            "type": "string",
            "title": "Run Id",
            "description": "Unique identifier for this clustering run"
          },
          "algorithm": {
            "$ref": "#/components/schemas/ClusteringAlgorithm",
            "description": "Algorithm used for clustering"
          },
          "num_clusters": {
            "type": "integer",
            "title": "Num Clusters",
            "description": "Number of clusters found"
          },
          "num_documents": {
            "type": "integer",
            "title": "Num Documents",
            "description": "Number of documents clustered"
          },
          "centroids": {
            "items": {
              "$ref": "#/components/schemas/ClusterCentroid"
            },
            "type": "array",
            "title": "Centroids",
            "description": "Cluster centroids with features"
          },
          "metrics": {
            "additionalProperties": {
              "type": "number"
            },
            "type": "object",
            "title": "Metrics",
            "description": "Clustering quality metrics"
          },
          "parquet_path": {
            "title": "Parquet Path",
            "description": "S3 key path to parquet file with full results",
            "type": "string",
            "nullable": true
          },
          "members_key": {
            "title": "Members Key",
            "description": "S3 key to members.parquet (if saved)",
            "type": "string",
            "nullable": true
          },
          "execution_time_ms": {
            "type": "integer",
            "title": "Execution Time Ms",
            "description": "Total execution time in milliseconds"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At",
            "description": "Timestamp of clustering"
          }
        },
        "type": "object",
        "required": [
          "success",
          "algorithm",
          "num_clusters",
          "num_documents",
          "centroids",
          "execution_time_ms"
        ],
        "title": "ExecuteClusterResponse",
        "description": "Response from cluster execution.",
        "examples": [
          {
            "algorithm": "kmeans",
            "centroids": [
              {
                "centroid_vector": [
                  0.1,
                  0.2,
                  0.3
                ],
                "cluster_id": "cluster_001",
                "feature_dimensions": 512,
                "num_members": 2000,
                "vector_name": "product_embedding"
              }
            ],
            "created_at": "2024-01-15T10:30:00Z",
            "execution_time_ms": 5432,
            "members_key": "int_abc123/ns_xyz789/engine_cluster_build/run_xyz789/members.parquet",
            "metrics": {
              "davies_bouldin_score": 0.8,
              "silhouette_score": 0.65
            },
            "num_clusters": 5,
            "num_documents": 10000,
            "parquet_path": "int_abc123/ns_xyz789/engine_cluster_build/run_xyz789/clusters.parquet",
            "run_id": "run_xyz789",
            "success": true
          }
        ]
      },
      "ExecuteTaxonomyRequest": {
        "properties": {
          "taxonomy": {
            "$ref": "#/components/schemas/TaxonomyModel",
            "description": "Full taxonomy model with configuration (fetched from DB by controller)"
          },
          "retriever": {
            "description": "Optional retriever configuration override for testing. If omitted, uses the retriever configured in the taxonomy.",
            "$ref": "#/components/schemas/RetrieverModel-Input",
            "nullable": true
          },
          "source_documents": {
            "title": "Source Documents",
            "description": "Optional documents to enrich for testing. If omitted, validates configuration without processing documents.",
            "items": {
              "additionalProperties": true,
              "type": "object"
            },
            "type": "array",
            "nullable": true
          },
          "source_collection_id": {
            "title": "Source Collection Id",
            "description": "Collection reference (for context/logging only in ON_DEMAND mode)",
            "type": "string",
            "nullable": true
          },
          "target_collection_id": {
            "title": "Target Collection Id",
            "description": "Not used in ON_DEMAND mode.",
            "type": "string",
            "nullable": true
          },
          "join_mode": {
            "$ref": "#/components/schemas/JoinMode",
            "description": "Must be `on_demand`. Batch mode is not supported via API.",
            "default": "on_demand"
          },
          "batch_size": {
            "type": "integer",
            "maximum": 10000.0,
            "minimum": 1.0,
            "title": "Batch Size",
            "description": "Batch size for the scroll iterator",
            "default": 1000
          },
          "scroll_filters": {
            "description": "Additional filters applied to the source collection prior to enrichment.",
            "$ref": "#/components/schemas/LogicalOperator-Input",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "taxonomy"
        ],
        "title": "ExecuteTaxonomyRequest",
        "description": "Request model for on-demand taxonomy validation and testing.\n\nNOTE: This endpoint only supports ON_DEMAND mode for testing/validation.\nBatch taxonomy materialization is automatically triggered by the engine\nafter feature extraction completes, based on collection configuration.",
        "examples": [
          {
            "batch_size": 1000,
            "join_mode": "on_demand",
            "source_collection_id": "col_catalog_v2",
            "target_collection_id": "col_catalog_enriched_v2",
            "taxonomy": {
              "config": {
                "input_mappings": [
                  {
                    "input_key": "image_vector",
                    "path": "features.clip",
                    "source_type": "vector"
                  }
                ],
                "retriever_id": "ret_clip_v1",
                "source_collection": {
                  "collection_id": "col_products_v1"
                },
                "taxonomy_type": "flat"
              },
              "input_mappings": [
                {
                  "input_key": "image_vector",
                  "path": "features.clip",
                  "source_type": "vector"
                }
              ],
              "namespace_id": "ns_123",
              "retriever_id": "ret_clip_v1",
              "taxonomy_name": "product_tags"
            }
          }
        ]
      },
      "FeatureAddress": {
        "properties": {
          "scheme": {
            "type": "string",
            "title": "Scheme",
            "default": "mixpeek"
          },
          "extractor": {
            "type": "string",
            "title": "Extractor"
          },
          "version": {
            "type": "string",
            "title": "Version"
          },
          "output": {
            "title": "Output",
            "type": "string",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "extractor",
          "version"
        ],
        "title": "FeatureAddress",
        "description": "Canonical feature address: mixpeek://{extractor}@{version}/{output}.\n\nShort form without the output segment is allowed only if the extractor has\na single vector output."
      },
      "FeatureExtractorConfig-Input": {
        "properties": {
          "feature_extractor_name": {
            "type": "string",
            "title": "Feature Extractor Name",
            "description": "Name of the feature extractor"
          },
          "version": {
            "type": "string",
            "title": "Version",
            "description": "Version of the feature extractor"
          },
          "parameters": {
            "additionalProperties": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/ParameterConfig"
                },
                {}
              ]
            },
            "type": "object",
            "title": "Parameters",
            "description": "Parameters for the feature extractor"
          },
          "input_mappings": {
            "anyOf": [
              {
                "additionalProperties": {
                  "type": "string"
                },
                "type": "object"
              },
              {
                "items": {
                  "$ref": "#/components/schemas/InputMapping"
                },
                "type": "array"
              }
            ],
            "title": "Input Mappings",
            "description": "Mapping from extractor input names to source values. Accepts either a simple dict of target->dot-path, or a list of generic InputMapping (payload/literal)."
          }
        },
        "type": "object",
        "required": [
          "feature_extractor_name",
          "version"
        ],
        "title": "FeatureExtractorConfig",
        "description": "Configuration for a feature extractor."
      },
      "FeatureExtractorConfig-Output": {
        "properties": {
          "feature_extractor_name": {
            "type": "string",
            "title": "Feature Extractor Name",
            "description": "Name of the feature extractor"
          },
          "version": {
            "type": "string",
            "title": "Version",
            "description": "Version of the feature extractor"
          },
          "parameters": {
            "additionalProperties": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/ParameterConfig"
                },
                {}
              ]
            },
            "type": "object",
            "title": "Parameters",
            "description": "Parameters for the feature extractor"
          },
          "input_mappings": {
            "anyOf": [
              {
                "additionalProperties": {
                  "type": "string"
                },
                "type": "object"
              },
              {
                "items": {
                  "$ref": "#/components/schemas/InputMapping"
                },
                "type": "array"
              }
            ],
            "title": "Input Mappings",
            "description": "Mapping from extractor input names to source values. Accepts either a simple dict of target->dot-path, or a list of generic InputMapping (payload/literal)."
          },
          "feature_extractor_id": {
            "type": "string",
            "title": "Feature Extractor Id",
            "description": "Construct unique identifier for the feature extractor instance (name + version).",
            "readOnly": true
          }
        },
        "type": "object",
        "required": [
          "feature_extractor_name",
          "version",
          "feature_extractor_id"
        ],
        "title": "FeatureExtractorConfig",
        "description": "Configuration for a feature extractor."
      },
      "FeatureExtractorResponseModel": {
        "properties": {
          "feature_extractor_name": {
            "type": "string",
            "title": "Feature Extractor Name"
          },
          "version": {
            "type": "string",
            "title": "Version"
          },
          "feature_extractor_id": {
            "type": "string",
            "title": "Feature Extractor Id"
          },
          "description": {
            "type": "string",
            "title": "Description"
          },
          "input_schema": {
            "additionalProperties": true,
            "type": "object",
            "title": "Input Schema"
          },
          "output_schema": {
            "additionalProperties": true,
            "type": "object",
            "title": "Output Schema"
          },
          "parameter_schema": {
            "title": "Parameter Schema",
            "additionalProperties": true,
            "type": "object",
            "nullable": true
          },
          "supported_input_types": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Supported Input Types"
          },
          "max_inputs": {
            "additionalProperties": {
              "type": "integer"
            },
            "type": "object",
            "title": "Max Inputs"
          },
          "default_parameters": {
            "additionalProperties": true,
            "type": "object",
            "title": "Default Parameters"
          },
          "document_output_type": {
            "$ref": "#/components/schemas/DocumentOutputType"
          },
          "document_input_handling": {
            "$ref": "#/components/schemas/DocumentInputHandling"
          },
          "required_vector_indexes": {
            "title": "Required Vector Indexes",
            "items": {
              "$ref": "#/components/schemas/VectorIndexDefinition"
            },
            "type": "array",
            "nullable": true
          },
          "required_payload_indexes": {
            "title": "Required Payload Indexes",
            "items": {
              "$ref": "#/components/schemas/PayloadIndexConfig-Output"
            },
            "type": "array",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "feature_extractor_name",
          "version",
          "feature_extractor_id",
          "description",
          "input_schema",
          "output_schema",
          "parameter_schema",
          "supported_input_types",
          "max_inputs",
          "default_parameters",
          "document_output_type",
          "document_input_handling",
          "required_vector_indexes",
          "required_payload_indexes"
        ],
        "title": "FeatureExtractorResponseModel",
        "description": "Feature extractor response model."
      },
      "FeatureModel": {
        "properties": {
          "feature_extractor_id": {
            "type": "string",
            "title": "Feature Extractor Id",
            "description": "ID of the feature extractor that produced this response"
          },
          "payload": {
            "additionalProperties": true,
            "type": "object",
            "title": "Payload",
            "description": "Metadata of the feature"
          },
          "vectors": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/DenseVector"
              },
              {
                "$ref": "#/components/schemas/SparseVector"
              },
              {
                "$ref": "#/components/schemas/MultiDenseVector"
              },
              {
                "$ref": "#/components/schemas/NamedDenseVectors"
              }
            ],
            "title": "Vectors",
            "description": "Vector representation of the feature. Can be any supported vector type.",
            "nullable": true
          }
        },
        "additionalProperties": true,
        "type": "object",
        "required": [
          "feature_extractor_id"
        ],
        "title": "FeatureModel",
        "description": "Response from a feature extractor."
      },
      "FeatureVectorRef": {
        "properties": {
          "feature_address": {
            "$ref": "#/components/schemas/FeatureAddress",
            "description": "Canonical feature address: mixpeek://{extractor}@{version}/{output}"
          }
        },
        "type": "object",
        "required": [
          "feature_address"
        ],
        "title": "FeatureVectorRef",
        "description": "Canonical reference to a feature vector produced by an extractor.\n\nUse a canonical feature address: mixpeek://{extractor}@{version}/{output}"
      },
      "FilterCondition": {
        "properties": {
          "field": {
            "type": "string",
            "title": "Field",
            "description": "Field name to filter on"
          },
          "operator": {
            "$ref": "#/components/schemas/FilterOperator",
            "description": "Comparison operator",
            "default": "eq"
          },
          "value": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/DynamicValue"
              },
              {}
            ],
            "title": "Value",
            "description": "Value to compare against"
          }
        },
        "type": "object",
        "required": [
          "field",
          "value"
        ],
        "title": "FilterCondition",
        "description": "Represents a single filter condition.\n\nAttributes:\n    field: The field to filter on\n    operator: The comparison operator\n    value: The value to compare against"
      },
      "FilterOperator": {
        "type": "string",
        "enum": [
          "eq",
          "ne",
          "gt",
          "lt",
          "gte",
          "lte",
          "in",
          "nin",
          "contains",
          "starts_with",
          "ends_with",
          "regex",
          "exists",
          "is_null",
          "text"
        ],
        "title": "FilterOperator",
        "description": "Supported filter operators across database implementations."
      },
      "FlatTaxonomyConfig-Input": {
        "properties": {
          "taxonomy_type": {
            "type": "string",
            "const": "flat",
            "title": "Taxonomy Type",
            "description": "Discriminator identifying this as a flat taxonomy.",
            "default": "flat"
          },
          "retriever_id": {
            "type": "string",
            "title": "Retriever Id",
            "description": "The retriever to use for matching against the source collection."
          },
          "input_mappings": {
            "items": {
              "$ref": "#/components/schemas/InputMapping"
            },
            "type": "array",
            "title": "Input Mappings",
            "description": "Input mappings defining how to construct retriever inputs."
          },
          "source_collection": {
            "$ref": "#/components/schemas/SourceCollection-Input",
            "description": "The single source collection for this flat taxonomy."
          }
        },
        "type": "object",
        "required": [
          "retriever_id",
          "input_mappings",
          "source_collection"
        ],
        "title": "FlatTaxonomyConfig",
        "description": "Configuration for a *flat* taxonomy - single source collection with one retriever.",
        "examples": [
          {
            "input_mappings": [
              {
                "input_key": "image_vector",
                "path": "features.clip_vit_l_14",
                "source_type": "vector"
              }
            ],
            "retriever_id": "ret_clip_v1",
            "source_collection": {
              "collection_id": "col_products_v1",
              "enrichment_fields": [
                {
                  "field_path": "metadata.tags",
                  "merge_mode": "append"
                }
              ]
            },
            "taxonomy_type": "flat"
          }
        ]
      },
      "FlatTaxonomyConfig-Output": {
        "properties": {
          "taxonomy_type": {
            "type": "string",
            "const": "flat",
            "title": "Taxonomy Type",
            "description": "Discriminator identifying this as a flat taxonomy.",
            "default": "flat"
          },
          "retriever_id": {
            "type": "string",
            "title": "Retriever Id",
            "description": "The retriever to use for matching against the source collection."
          },
          "input_mappings": {
            "items": {
              "$ref": "#/components/schemas/InputMapping"
            },
            "type": "array",
            "title": "Input Mappings",
            "description": "Input mappings defining how to construct retriever inputs."
          },
          "source_collection": {
            "$ref": "#/components/schemas/SourceCollection-Output",
            "description": "The single source collection for this flat taxonomy."
          }
        },
        "type": "object",
        "required": [
          "retriever_id",
          "input_mappings",
          "source_collection"
        ],
        "title": "FlatTaxonomyConfig",
        "description": "Configuration for a *flat* taxonomy - single source collection with one retriever.",
        "examples": [
          {
            "input_mappings": [
              {
                "input_key": "image_vector",
                "path": "features.clip_vit_l_14",
                "source_type": "vector"
              }
            ],
            "retriever_id": "ret_clip_v1",
            "source_collection": {
              "collection_id": "col_products_v1",
              "enrichment_fields": [
                {
                  "field_path": "metadata.tags",
                  "merge_mode": "append"
                }
              ]
            },
            "taxonomy_type": "flat"
          }
        ]
      },
      "FloatIndexParams": {
        "properties": {
          "type": {
            "type": "string",
            "title": "Type",
            "default": "float"
          }
        },
        "type": "object",
        "title": "FloatIndexParams",
        "description": "Configuration for float index."
      },
      "GaussianMixtureParams": {
        "properties": {
          "n_components": {
            "type": "integer",
            "minimum": 1.0,
            "title": "N Components",
            "description": "Number of mixture components",
            "default": 1
          },
          "covariance_type": {
            "type": "string",
            "title": "Covariance Type",
            "description": "Type of covariance parameters ('full', 'tied', 'diag', 'spherical')",
            "default": "full"
          },
          "tol": {
            "type": "number",
            "exclusiveMinimum": 0.0,
            "title": "Tol",
            "description": "Convergence threshold",
            "default": 0.001
          },
          "reg_covar": {
            "type": "number",
            "minimum": 0.0,
            "title": "Reg Covar",
            "description": "Regularization added to the diagonal of covariance",
            "default": 1e-06
          },
          "max_iter": {
            "type": "integer",
            "minimum": 1.0,
            "title": "Max Iter",
            "description": "Maximum number of EM iterations",
            "default": 100
          },
          "n_init": {
            "type": "integer",
            "minimum": 1.0,
            "title": "N Init",
            "description": "Number of initializations to perform",
            "default": 1
          },
          "init_params": {
            "type": "string",
            "title": "Init Params",
            "description": "Method used to initialize weights, means and covariances ('kmeans' or 'random')",
            "default": "kmeans"
          },
          "weights_init": {
            "title": "Weights Init",
            "description": "Initial weights",
            "items": {},
            "type": "array",
            "nullable": true
          },
          "means_init": {
            "title": "Means Init",
            "description": "Initial means",
            "items": {},
            "type": "array",
            "nullable": true
          },
          "precisions_init": {
            "title": "Precisions Init",
            "description": "Initial precisions",
            "items": {},
            "type": "array",
            "nullable": true
          },
          "random_state": {
            "title": "Random State",
            "description": "Random seed for reproducibility",
            "default": 42,
            "type": "integer",
            "nullable": true
          },
          "warm_start": {
            "type": "boolean",
            "title": "Warm Start",
            "description": "If True, use the solution of the last fit as initialization",
            "default": false
          },
          "verbose": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Verbose",
            "description": "Enable verbose output",
            "default": 0
          },
          "verbose_interval": {
            "type": "integer",
            "minimum": 1.0,
            "title": "Verbose Interval",
            "description": "Number of iterations between each verbose message",
            "default": 10
          }
        },
        "type": "object",
        "title": "GaussianMixtureParams",
        "description": "Parameters for Gaussian Mixture Model clustering."
      },
      "GenericDeleteResponse": {
        "properties": {
          "message": {
            "type": "string",
            "title": "Message",
            "default": "Successfully deleted"
          },
          "success": {
            "type": "boolean",
            "title": "Success",
            "default": true
          }
        },
        "type": "object",
        "title": "GenericDeleteResponse",
        "description": "GenericDeleteResponse."
      },
      "GenericSuccessResponse": {
        "properties": {
          "message": {
            "type": "string",
            "title": "Message",
            "default": "Successfully completed"
          },
          "success": {
            "type": "boolean",
            "title": "Success",
            "default": true
          }
        },
        "type": "object",
        "title": "GenericSuccessResponse",
        "description": "GenericSuccessResponse."
      },
      "GeoIndexParams": {
        "properties": {
          "type": {
            "type": "string",
            "title": "Type",
            "default": "geo"
          }
        },
        "type": "object",
        "title": "GeoIndexParams",
        "description": "Configuration for geo index."
      },
      "GroupByOption": {
        "properties": {
          "field": {
            "type": "string",
            "title": "Field",
            "description": "The field to group by."
          },
          "max_features": {
            "type": "integer",
            "minimum": 1.0,
            "title": "Max Features",
            "description": "The maximum number of features (documents) to return per group.",
            "default": 10
          },
          "sort": {
            "description": "Optional sorting options to apply within each group.",
            "$ref": "#/components/schemas/SortOption",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "field"
        ],
        "title": "GroupByOption",
        "description": "Options for grouping results by a specific field.\n\nAttributes:\n    field: The field to group by.\n    max_features: The maximum number of features (documents) to return per group.\n    sort: Optional sorting options to apply within each group."
      },
      "GroupedResultItem": {
        "properties": {
          "field": {
            "type": "string",
            "title": "Field",
            "description": "The field by which the results were grouped."
          },
          "key": {
            "title": "Key",
            "description": "The value of the group_by field for this group."
          },
          "group": {
            "items": {
              "$ref": "#/components/schemas/DocumentResult"
            },
            "type": "array",
            "title": "Group",
            "description": "The documents belonging to this group."
          }
        },
        "type": "object",
        "required": [
          "field",
          "key",
          "group"
        ],
        "title": "GroupedResultItem",
        "description": "Represents a single group of documents within grouped search results.\n\nAttributes:\n    field: The field by which the results were grouped.\n    key: The value of the group_by field for this group.\n    group: The documents belonging to this group."
      },
      "HDBSCANParams": {
        "properties": {
          "min_cluster_size": {
            "type": "integer",
            "minimum": 2.0,
            "title": "Min Cluster Size",
            "description": "Minimum number of samples in a cluster",
            "default": 5
          },
          "min_samples": {
            "title": "Min Samples",
            "description": "Number of samples in a neighborhood for a point to be considered a core point. Defaults to min_cluster_size if None",
            "type": "integer",
            "minimum": 1.0,
            "nullable": true
          },
          "cluster_selection_epsilon": {
            "type": "number",
            "minimum": 0.0,
            "title": "Cluster Selection Epsilon",
            "description": "A distance threshold for cluster selection. Clusters below this value will be merged",
            "default": 0.0
          },
          "max_cluster_size": {
            "title": "Max Cluster Size",
            "description": "Maximum number of samples in a cluster. Clusters above this size will be split",
            "type": "integer",
            "minimum": 1.0,
            "nullable": true
          },
          "metric": {
            "type": "string",
            "title": "Metric",
            "description": "Metric to use for distance computation",
            "default": "euclidean"
          },
          "alpha": {
            "type": "number",
            "exclusiveMinimum": 0.0,
            "title": "Alpha",
            "description": "A distance scaling parameter",
            "default": 1.0
          },
          "cluster_selection_method": {
            "type": "string",
            "title": "Cluster Selection Method",
            "description": "Method to select clusters from the condensed tree ('eom' or 'leaf')",
            "default": "eom"
          },
          "allow_single_cluster": {
            "type": "boolean",
            "title": "Allow Single Cluster",
            "description": "Allow HDBSCAN to find only a single cluster",
            "default": false
          },
          "prediction_data": {
            "type": "boolean",
            "title": "Prediction Data",
            "description": "Whether to generate extra data for predicting cluster membership",
            "default": false
          },
          "match_reference_implementation": {
            "type": "boolean",
            "title": "Match Reference Implementation",
            "description": "Whether to match the reference implementation exactly",
            "default": false
          }
        },
        "type": "object",
        "title": "HDBSCANParams",
        "description": "Parameters for HDBSCAN clustering algorithm."
      },
      "HTTPValidationError": {
        "properties": {
          "detail": {
            "items": {
              "$ref": "#/components/schemas/ValidationError"
            },
            "type": "array",
            "title": "Detail"
          }
        },
        "type": "object",
        "title": "HTTPValidationError"
      },
      "HealthCheck-Input": {
        "properties": {
          "status": {
            "$ref": "#/components/schemas/HealthStatus-Input",
            "description": "Current health status",
            "default": "healthy"
          },
          "last_check": {
            "title": "Last Check",
            "description": "When the health was last checked",
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "issues": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Issues",
            "description": "List of current issues if any"
          }
        },
        "type": "object",
        "title": "HealthCheck",
        "description": "Health check information for a retriever."
      },
      "HealthCheck-Output": {
        "properties": {
          "status": {
            "$ref": "#/components/schemas/shared__retrievers__models__HealthStatus",
            "description": "Current health status",
            "default": "healthy"
          },
          "last_check": {
            "title": "Last Check",
            "description": "When the health was last checked",
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "issues": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Issues",
            "description": "List of current issues if any"
          }
        },
        "type": "object",
        "title": "HealthCheck",
        "description": "Health check information for a retriever."
      },
      "HealthCheckResponse": {
        "properties": {
          "status": {
            "$ref": "#/components/schemas/api__health__HealthStatus",
            "description": "Overall API health status"
          },
          "data": {
            "$ref": "#/components/schemas/HealthServiceStatus",
            "description": "Per-service health status flags"
          },
          "errors": {
            "description": "Optional per-service error messages when a service check fails",
            "$ref": "#/components/schemas/HealthServiceErrors",
            "nullable": true
          },
          "meta": {
            "title": "Meta",
            "description": "Optional metadata such as configured S3 bucket/region/endpoint",
            "additionalProperties": true,
            "type": "object",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "status",
          "data"
        ],
        "title": "HealthCheckResponse",
        "description": "Health check response model."
      },
      "HealthServiceErrors": {
        "properties": {
          "redis": {
            "title": "Redis",
            "description": "Redis error message, if any",
            "type": "string",
            "nullable": true
          },
          "mongodb": {
            "title": "Mongodb",
            "description": "MongoDB error message, if any",
            "type": "string",
            "nullable": true
          },
          "qdrant": {
            "title": "Qdrant",
            "description": "Qdrant error message, if any",
            "type": "string",
            "nullable": true
          },
          "s3": {
            "title": "S3",
            "description": "S3 error message, if any",
            "type": "string",
            "nullable": true
          },
          "celery": {
            "title": "Celery",
            "description": "Celery error message, if any",
            "type": "string",
            "nullable": true
          },
          "engine": {
            "title": "Engine",
            "description": "Engine error message, if any",
            "type": "string",
            "nullable": true
          }
        },
        "type": "object",
        "title": "HealthServiceErrors",
        "description": "Optional error messages for dependent services (present when a check fails)."
      },
      "HealthServiceStatus": {
        "properties": {
          "redis": {
            "type": "boolean",
            "title": "Redis",
            "description": "Connectivity to Redis successful",
            "examples": [
              true
            ]
          },
          "mongodb": {
            "type": "boolean",
            "title": "Mongodb",
            "description": "Connectivity to MongoDB successful",
            "examples": [
              true
            ]
          },
          "qdrant": {
            "type": "boolean",
            "title": "Qdrant",
            "description": "Connectivity to Qdrant successful",
            "examples": [
              true
            ]
          },
          "s3": {
            "type": "boolean",
            "title": "S3",
            "description": "Connectivity to S3 successful",
            "examples": [
              true
            ]
          },
          "celery": {
            "type": "boolean",
            "title": "Celery",
            "description": "Celery task execution successful",
            "examples": [
              true
            ]
          },
          "engine": {
            "type": "boolean",
            "title": "Engine",
            "description": "Engine HTTP health endpoint responded healthy",
            "examples": [
              true
            ]
          }
        },
        "type": "object",
        "required": [
          "redis",
          "mongodb",
          "qdrant",
          "s3",
          "celery",
          "engine"
        ],
        "title": "HealthServiceStatus",
        "description": "Status flags for dependent services."
      },
      "HealthStatus-Input": {
        "type": "string",
        "enum": [
          "healthy",
          "degraded",
          "unhealthy"
        ],
        "title": "HealthStatus",
        "description": "Health status of a retriever."
      },
      "HierarchicalNode-Input": {
        "properties": {
          "collection_id": {
            "type": "string",
            "title": "Collection Id",
            "description": "The ID of the collection representing this node in the hierarchy."
          },
          "parent_collection_id": {
            "title": "Parent Collection Id",
            "description": "The ID of the parent collection in the hierarchy (``None`` for root nodes).",
            "type": "string",
            "nullable": true
          },
          "label": {
            "title": "Label",
            "description": "Optional human-readable label for the node",
            "type": "string",
            "nullable": true
          },
          "summary": {
            "title": "Summary",
            "description": "Optional summary describing the node",
            "type": "string",
            "nullable": true
          },
          "keywords": {
            "title": "Keywords",
            "description": "Optional keywords associated with the node",
            "items": {
              "type": "string"
            },
            "type": "array",
            "nullable": true
          },
          "retriever_id": {
            "title": "Retriever Id",
            "description": "Optional per-node retriever. If omitted, taxonomy-level `retriever_id` (if provided) is used.",
            "type": "string",
            "nullable": true
          },
          "enrichment_fields": {
            "title": "Enrichment Fields",
            "description": "Optional field-level enrichment behaviour for this specific node.",
            "items": {
              "$ref": "#/components/schemas/EnrichmentField"
            },
            "type": "array",
            "nullable": true
          },
          "input_mappings": {
            "title": "Input Mappings",
            "description": "Optional override of the taxonomy-level input_mappings when this node is matched.",
            "items": {
              "$ref": "#/components/schemas/InputMapping"
            },
            "type": "array",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "collection_id"
        ],
        "title": "HierarchicalNode",
        "description": "A node in a hierarchical taxonomy (explicit representation).",
        "examples": [
          {
            "collection_id": "col_executives_v1",
            "enrichment_fields": [
              {
                "field_path": "role",
                "merge_mode": "replace"
              }
            ],
            "input_mappings": [
              {
                "input_key": "face_vec",
                "path": "features.face",
                "source_type": "vector"
              }
            ],
            "parent_collection_id": "col_employees_v1",
            "retriever_id": "ret_face_v1"
          }
        ]
      },
      "HierarchicalNode-Output": {
        "properties": {
          "collection_id": {
            "type": "string",
            "title": "Collection Id",
            "description": "The ID of the collection representing this node in the hierarchy."
          },
          "parent_collection_id": {
            "title": "Parent Collection Id",
            "description": "The ID of the parent collection in the hierarchy (``None`` for root nodes).",
            "type": "string",
            "nullable": true
          },
          "label": {
            "title": "Label",
            "description": "Optional human-readable label for the node",
            "type": "string",
            "nullable": true
          },
          "summary": {
            "title": "Summary",
            "description": "Optional summary describing the node",
            "type": "string",
            "nullable": true
          },
          "keywords": {
            "title": "Keywords",
            "description": "Optional keywords associated with the node",
            "items": {
              "type": "string"
            },
            "type": "array",
            "nullable": true
          },
          "retriever_id": {
            "title": "Retriever Id",
            "description": "Optional per-node retriever. If omitted, taxonomy-level `retriever_id` (if provided) is used.",
            "type": "string",
            "nullable": true
          },
          "enrichment_fields": {
            "title": "Enrichment Fields",
            "description": "Optional field-level enrichment behaviour for this specific node.",
            "items": {
              "$ref": "#/components/schemas/EnrichmentField"
            },
            "type": "array",
            "nullable": true
          },
          "input_mappings": {
            "title": "Input Mappings",
            "description": "Optional override of the taxonomy-level input_mappings when this node is matched.",
            "items": {
              "$ref": "#/components/schemas/InputMapping"
            },
            "type": "array",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "collection_id"
        ],
        "title": "HierarchicalNode",
        "description": "A node in a hierarchical taxonomy (explicit representation).",
        "examples": [
          {
            "collection_id": "col_executives_v1",
            "enrichment_fields": [
              {
                "field_path": "role",
                "merge_mode": "replace"
              }
            ],
            "input_mappings": [
              {
                "input_key": "face_vec",
                "path": "features.face",
                "source_type": "vector"
              }
            ],
            "parent_collection_id": "col_employees_v1",
            "retriever_id": "ret_face_v1"
          }
        ]
      },
      "HierarchicalTaxonomyConfig-Input": {
        "properties": {
          "taxonomy_type": {
            "type": "string",
            "const": "hierarchical",
            "title": "Taxonomy Type",
            "description": "Discriminator identifying this as a hierarchical taxonomy.",
            "default": "hierarchical"
          },
          "retriever_id": {
            "title": "Retriever Id",
            "description": "Default retriever to use for all nodes unless overridden per-node.",
            "type": "string",
            "nullable": true
          },
          "input_mappings": {
            "title": "Input Mappings",
            "description": "Default input mappings for all nodes unless overridden per-node.",
            "items": {
              "$ref": "#/components/schemas/InputMapping"
            },
            "type": "array",
            "nullable": true
          },
          "inference_strategy": {
            "description": "Strategy for inferring hierarchy structure from collections. Can be 'schema' (overlap-based), 'cluster' (clustering-based), or 'llm' (AI-based). When set, will infer relationships from inference_collections.",
            "$ref": "#/components/schemas/HierarchyInferenceStrategy",
            "nullable": true
          },
          "inference_collections": {
            "title": "Inference Collections",
            "description": "Collection IDs to use for hierarchy inference. The inference_strategy will analyze these collections to discover relationships. Can be combined with hierarchical_nodes for hybrid configuration.",
            "items": {
              "type": "string"
            },
            "type": "array",
            "nullable": true
          },
          "llm_provider": {
            "title": "Llm Provider",
            "description": "LLM provider to use for hierarchy inference (default openai_chat_v1)",
            "type": "string",
            "const": "openai_chat_v1",
            "nullable": true
          },
          "llm_model": {
            "title": "Llm Model",
            "description": "LLM model name (e.g., gpt-4o-mini)",
            "type": "string",
            "nullable": true
          },
          "llm_prompt_template": {
            "title": "Llm Prompt Template",
            "description": "Optional prompt template. Variables available: {collection_id}, {collection_name}.",
            "type": "string",
            "nullable": true
          },
          "llm_sample_size": {
            "type": "integer",
            "title": "Llm Sample Size",
            "description": "Optional number of sample docs to include in prompts (0 = disabled).",
            "default": 0
          },
          "cluster_ids": {
            "title": "Cluster Ids",
            "description": "Cluster IDs to use for CLUSTER inference strategy",
            "items": {
              "type": "string"
            },
            "type": "array",
            "nullable": true
          },
          "cluster_overlap_threshold": {
            "type": "number",
            "title": "Cluster Overlap Threshold",
            "description": "Minimum overlap ratio to establish parent-child relationship between clusters",
            "default": 0.7
          },
          "hierarchical_nodes": {
            "title": "Hierarchical Nodes",
            "description": "Explicit node definitions that either: 1) Define the entire hierarchy (when inference_strategy is None), 2) Add additional nodes to an inferred hierarchy, or 3) Override specific relationships in an inferred hierarchy. Supports true hybrid: infer from some collections, manually add others.",
            "items": {
              "$ref": "#/components/schemas/HierarchicalNode-Input"
            },
            "type": "array",
            "nullable": true
          }
        },
        "type": "object",
        "title": "HierarchicalTaxonomyConfig",
        "description": "Hybrid hierarchical taxonomy configuration supporting inference with manual additions.\n\nAll hierarchical taxonomies are hybrid:\n- Base hierarchy can be inferred via schema, clustering, or LLM\n- Additional collections can be explicitly added with specific retrievers\n- Supports mixing inference strategies with manual additions/overrides\n\nExamples:\n1. Pure inference: Set inference_strategy + inference_collections\n2. Pure manual: Set hierarchical_nodes only\n3. Hybrid: Set inference_strategy + inference_collections + hierarchical_nodes\n   (infers base from collections, adds/overrides with explicit nodes)",
        "examples": [
          {
            "hierarchical_nodes": [
              {
                "collection_id": "col_employees_v1"
              },
              {
                "collection_id": "col_executives_v1",
                "parent_collection_id": "col_employees_v1"
              }
            ],
            "input_mappings": [
              {
                "input_key": "face_vec",
                "path": "features.face",
                "source_type": "vector"
              }
            ],
            "retriever_id": "ret_face_v1",
            "taxonomy_type": "hierarchical"
          },
          {
            "inference_collections": [
              "col_people_v1",
              "col_employees_v1",
              "col_managers_v1"
            ],
            "inference_strategy": "schema",
            "input_mappings": [
              {
                "input_key": "face_vec",
                "path": "features.face",
                "source_type": "vector"
              }
            ],
            "retriever_id": "ret_face_v1",
            "taxonomy_type": "hierarchical"
          },
          {
            "hierarchical_nodes": [
              {
                "collection_id": "col_special_products",
                "enrichment_fields": [
                  {
                    "field_path": "premium_tags",
                    "merge_mode": "append"
                  }
                ],
                "parent_collection_id": "col_products_v1",
                "retriever_id": "ret_special_v1"
              }
            ],
            "inference_collections": [
              "col_products_v1",
              "col_categories_v1"
            ],
            "inference_strategy": "cluster",
            "retriever_id": "ret_clip_v1",
            "taxonomy_type": "hierarchical"
          }
        ]
      },
      "HierarchicalTaxonomyConfig-Output": {
        "properties": {
          "taxonomy_type": {
            "type": "string",
            "const": "hierarchical",
            "title": "Taxonomy Type",
            "description": "Discriminator identifying this as a hierarchical taxonomy.",
            "default": "hierarchical"
          },
          "retriever_id": {
            "title": "Retriever Id",
            "description": "Default retriever to use for all nodes unless overridden per-node.",
            "type": "string",
            "nullable": true
          },
          "input_mappings": {
            "title": "Input Mappings",
            "description": "Default input mappings for all nodes unless overridden per-node.",
            "items": {
              "$ref": "#/components/schemas/InputMapping"
            },
            "type": "array",
            "nullable": true
          },
          "inference_strategy": {
            "description": "Strategy for inferring hierarchy structure from collections. Can be 'schema' (overlap-based), 'cluster' (clustering-based), or 'llm' (AI-based). When set, will infer relationships from inference_collections.",
            "$ref": "#/components/schemas/HierarchyInferenceStrategy",
            "nullable": true
          },
          "inference_collections": {
            "title": "Inference Collections",
            "description": "Collection IDs to use for hierarchy inference. The inference_strategy will analyze these collections to discover relationships. Can be combined with hierarchical_nodes for hybrid configuration.",
            "items": {
              "type": "string"
            },
            "type": "array",
            "nullable": true
          },
          "llm_provider": {
            "title": "Llm Provider",
            "description": "LLM provider to use for hierarchy inference (default openai_chat_v1)",
            "type": "string",
            "const": "openai_chat_v1",
            "nullable": true
          },
          "llm_model": {
            "title": "Llm Model",
            "description": "LLM model name (e.g., gpt-4o-mini)",
            "type": "string",
            "nullable": true
          },
          "llm_prompt_template": {
            "title": "Llm Prompt Template",
            "description": "Optional prompt template. Variables available: {collection_id}, {collection_name}.",
            "type": "string",
            "nullable": true
          },
          "llm_sample_size": {
            "type": "integer",
            "title": "Llm Sample Size",
            "description": "Optional number of sample docs to include in prompts (0 = disabled).",
            "default": 0
          },
          "cluster_ids": {
            "title": "Cluster Ids",
            "description": "Cluster IDs to use for CLUSTER inference strategy",
            "items": {
              "type": "string"
            },
            "type": "array",
            "nullable": true
          },
          "cluster_overlap_threshold": {
            "type": "number",
            "title": "Cluster Overlap Threshold",
            "description": "Minimum overlap ratio to establish parent-child relationship between clusters",
            "default": 0.7
          },
          "hierarchical_nodes": {
            "title": "Hierarchical Nodes",
            "description": "Explicit node definitions that either: 1) Define the entire hierarchy (when inference_strategy is None), 2) Add additional nodes to an inferred hierarchy, or 3) Override specific relationships in an inferred hierarchy. Supports true hybrid: infer from some collections, manually add others.",
            "items": {
              "$ref": "#/components/schemas/HierarchicalNode-Output"
            },
            "type": "array",
            "nullable": true
          }
        },
        "type": "object",
        "title": "HierarchicalTaxonomyConfig",
        "description": "Hybrid hierarchical taxonomy configuration supporting inference with manual additions.\n\nAll hierarchical taxonomies are hybrid:\n- Base hierarchy can be inferred via schema, clustering, or LLM\n- Additional collections can be explicitly added with specific retrievers\n- Supports mixing inference strategies with manual additions/overrides\n\nExamples:\n1. Pure inference: Set inference_strategy + inference_collections\n2. Pure manual: Set hierarchical_nodes only\n3. Hybrid: Set inference_strategy + inference_collections + hierarchical_nodes\n   (infers base from collections, adds/overrides with explicit nodes)",
        "examples": [
          {
            "hierarchical_nodes": [
              {
                "collection_id": "col_employees_v1"
              },
              {
                "collection_id": "col_executives_v1",
                "parent_collection_id": "col_employees_v1"
              }
            ],
            "input_mappings": [
              {
                "input_key": "face_vec",
                "path": "features.face",
                "source_type": "vector"
              }
            ],
            "retriever_id": "ret_face_v1",
            "taxonomy_type": "hierarchical"
          },
          {
            "inference_collections": [
              "col_people_v1",
              "col_employees_v1",
              "col_managers_v1"
            ],
            "inference_strategy": "schema",
            "input_mappings": [
              {
                "input_key": "face_vec",
                "path": "features.face",
                "source_type": "vector"
              }
            ],
            "retriever_id": "ret_face_v1",
            "taxonomy_type": "hierarchical"
          },
          {
            "hierarchical_nodes": [
              {
                "collection_id": "col_special_products",
                "enrichment_fields": [
                  {
                    "field_path": "premium_tags",
                    "merge_mode": "append"
                  }
                ],
                "parent_collection_id": "col_products_v1",
                "retriever_id": "ret_special_v1"
              }
            ],
            "inference_collections": [
              "col_products_v1",
              "col_categories_v1"
            ],
            "inference_strategy": "cluster",
            "retriever_id": "ret_clip_v1",
            "taxonomy_type": "hierarchical"
          }
        ]
      },
      "HierarchyInferenceStrategy": {
        "type": "string",
        "enum": [
          "schema",
          "cluster",
          "llm"
        ],
        "title": "HierarchyInferenceStrategy",
        "description": "Strategy for inferring the base hierarchy structure.\n\nCan be combined with manual overrides via hierarchical_nodes for hybrid configuration:\n- SCHEMA: Infer based on overlapping collection schemas\n- CLUSTER: Infer based on clustering algorithms and overlap detection\n- LLM: Infer using AI/language models"
      },
      "InferenceRequest": {
        "properties": {
          "inference_name": {
            "type": "string",
            "title": "Inference Name",
            "description": "Name of the inference model to use"
          },
          "inputs": {
            "additionalProperties": true,
            "type": "object",
            "title": "Inputs",
            "description": "Input data for the inference"
          },
          "parameters": {
            "title": "Parameters",
            "description": "Additional parameters for the inference",
            "additionalProperties": true,
            "type": "object",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "inference_name",
          "inputs"
        ],
        "title": "InferenceRequest",
        "description": "Request model for inference services."
      },
      "InputMapping": {
        "properties": {
          "input_key": {
            "type": "string",
            "title": "Input Key",
            "description": "Key used in the constructed inputs payload."
          },
          "source_type": {
            "description": "Source of the value (payload, literal, vector).",
            "$ref": "#/components/schemas/InputSourceType",
            "nullable": true
          },
          "path": {
            "title": "Path",
            "description": "Dot-notation path inside payload/vector when source_type is PAYLOAD or VECTOR.",
            "type": "string",
            "nullable": true
          },
          "override": {
            "title": "Override",
            "description": "Static value used when source_type is LITERAL. Overrides any path.",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "input_key"
        ],
        "title": "InputMapping",
        "description": "Declarative mapping for building inputs from various sources.\n\n- input_key: The key used in the constructed inputs payload\n- source_type: Where to fetch the value (payload, literal, vector)\n- path: Dot-notation path when source_type is PAYLOAD or VECTOR\n- override: Static value when source_type is LITERAL",
        "examples": [
          {
            "input_key": "query_text",
            "path": "content.title",
            "source_type": "payload"
          },
          {
            "input_key": "lang",
            "override": "en",
            "source_type": "literal"
          },
          {
            "input_key": "image_vector",
            "path": "features.clip_vit_l_14",
            "source_type": "vector"
          }
        ]
      },
      "InputSourceType": {
        "type": "string",
        "enum": [
          "payload",
          "literal",
          "vector"
        ],
        "title": "InputSourceType",
        "description": "Where the value for an input should be retrieved from."
      },
      "IntegerIndexParams": {
        "properties": {
          "type": {
            "type": "string",
            "title": "Type",
            "default": "integer"
          },
          "lookup": {
            "type": "boolean",
            "title": "Lookup",
            "default": true
          },
          "range": {
            "type": "boolean",
            "title": "Range",
            "default": true
          }
        },
        "type": "object",
        "title": "IntegerIndexParams",
        "description": "Configuration for integer index."
      },
      "JoinMode": {
        "type": "string",
        "enum": [
          "on_demand",
          "batch"
        ],
        "title": "JoinMode"
      },
      "JoinResponse": {
        "properties": {
          "stats": {
            "$ref": "#/components/schemas/JoinStats"
          },
          "results": {
            "title": "Results",
            "items": {
              "additionalProperties": true,
              "type": "object"
            },
            "type": "array",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "stats"
        ],
        "title": "JoinResponse"
      },
      "JoinStats": {
        "properties": {
          "processed_docs": {
            "type": "integer",
            "title": "Processed Docs",
            "default": 0
          },
          "batches": {
            "type": "integer",
            "title": "Batches",
            "default": 0
          },
          "errors": {
            "type": "integer",
            "title": "Errors",
            "default": 0
          }
        },
        "type": "object",
        "title": "JoinStats"
      },
      "KMeansParams": {
        "properties": {
          "n_clusters": {
            "type": "integer",
            "maximum": 1000.0,
            "minimum": 2.0,
            "title": "N Clusters",
            "description": "Number of clusters to form",
            "default": 8
          },
          "max_iter": {
            "type": "integer",
            "maximum": 10000.0,
            "minimum": 1.0,
            "title": "Max Iter",
            "description": "Maximum number of iterations",
            "default": 300
          },
          "random_state": {
            "title": "Random State",
            "description": "Random seed for reproducibility",
            "default": 42,
            "type": "integer",
            "nullable": true
          },
          "n_init": {
            "type": "integer",
            "minimum": 1.0,
            "title": "N Init",
            "description": "Number of times k-means will run with different centroid seeds",
            "default": 10
          },
          "tol": {
            "type": "number",
            "exclusiveMinimum": 0.0,
            "title": "Tol",
            "description": "Tolerance for convergence",
            "default": 0.0001
          },
          "init": {
            "type": "string",
            "title": "Init",
            "description": "Method for initialization ('k-means++' or 'random')",
            "default": "k-means++"
          },
          "verbose": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Verbose",
            "description": "Verbosity mode",
            "default": 0
          },
          "copy_x": {
            "type": "boolean",
            "title": "Copy X",
            "description": "If True, the original data is not modified",
            "default": true
          },
          "algorithm": {
            "type": "string",
            "title": "Algorithm",
            "description": "K-means algorithm to use ('lloyd', 'elkan', or 'auto')",
            "default": "lloyd"
          }
        },
        "type": "object",
        "title": "KMeansParams",
        "description": "Parameters for K-Means clustering algorithm."
      },
      "KeywordIndexParams": {
        "properties": {
          "type": {
            "type": "string",
            "title": "Type",
            "default": "keyword"
          },
          "is_tenant": {
            "type": "boolean",
            "title": "Is Tenant",
            "default": false
          }
        },
        "type": "object",
        "title": "KeywordIndexParams",
        "description": "Configuration for keyword index."
      },
      "LLMLabeling": {
        "properties": {
          "enabled": {
            "type": "boolean",
            "title": "Enabled",
            "description": "Whether to generate labels for clusters using LLM",
            "default": false
          },
          "provider": {
            "title": "Provider",
            "description": "LLM provider to use for labeling. Supported: 'openai', 'google'",
            "type": "string",
            "enum": [
              "openai",
              "google"
            ],
            "nullable": true
          },
          "model_name": {
            "title": "Model Name",
            "description": "LLM model identifier. For OpenAI defaults to 'gpt-4o-mini'. For Google defaults to 'gemini-2.5-flash'.",
            "type": "string",
            "nullable": true
          },
          "include_summary": {
            "type": "boolean",
            "title": "Include Summary",
            "description": "Whether to generate cluster summaries",
            "default": true
          },
          "include_keywords": {
            "type": "boolean",
            "title": "Include Keywords",
            "description": "Whether to extract keywords for clusters",
            "default": true
          },
          "max_samples_per_cluster": {
            "type": "integer",
            "title": "Max Samples Per Cluster",
            "description": "Maximum samples to send to LLM per cluster",
            "default": 10
          },
          "custom_prompt": {
            "title": "Custom Prompt",
            "description": "Custom prompt template for labeling",
            "type": "string",
            "nullable": true
          },
          "parameters": {
            "additionalProperties": true,
            "type": "object",
            "title": "Parameters",
            "description": "Provider-specific parameters forwarded to the LLM service. For OpenAI: temperature, max_tokens, top_p, json_output, etc. For Google: temperature, top_k, max_output_tokens, json_output, etc."
          }
        },
        "type": "object",
        "title": "LLMLabeling",
        "description": "Configuration for LLM-based cluster labeling."
      },
      "ListBatchesRequest": {
        "properties": {
          "status": {
            "description": "Filter batches by status.",
            "$ref": "#/components/schemas/TaskStatusEnum",
            "nullable": true
          },
          "offset": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Offset",
            "description": "The number of batches to skip.",
            "default": 0
          },
          "limit": {
            "type": "integer",
            "maximum": 1000.0,
            "minimum": 1.0,
            "title": "Limit",
            "description": "The maximum number of batches to return.",
            "default": 100
          }
        },
        "type": "object",
        "title": "ListBatchesRequest",
        "description": "The request model for listing batches."
      },
      "ListBatchesResponse": {
        "properties": {
          "batches": {
            "items": {
              "$ref": "#/components/schemas/BatchModel"
            },
            "type": "array",
            "title": "Batches",
            "description": "A list of batches."
          },
          "total_count": {
            "type": "integer",
            "title": "Total Count",
            "description": "The total number of batches found."
          }
        },
        "type": "object",
        "required": [
          "batches",
          "total_count"
        ],
        "title": "ListBatchesResponse",
        "description": "The response model for listing batches."
      },
      "ListBucketsRequest": {
        "properties": {
          "search": {
            "title": "Search",
            "description": "Search term for wildcard search across all text fields",
            "type": "string",
            "nullable": true
          },
          "filters": {
            "title": "Filters",
            "description": "Filters to apply to the bucket list",
            "additionalProperties": true,
            "type": "object",
            "nullable": true
          },
          "sort": {
            "title": "Sort",
            "description": "Sort options for the bucket list",
            "additionalProperties": true,
            "type": "object",
            "nullable": true
          },
          "case_sensitive": {
            "type": "boolean",
            "title": "Case Sensitive",
            "description": "If True, filters and search will be case-sensitive",
            "default": false
          },
          "limit": {
            "type": "integer",
            "maximum": 100.0,
            "minimum": 1.0,
            "title": "Limit",
            "description": "Number of results to return",
            "default": 10
          },
          "offset": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Offset",
            "description": "Number of results to skip",
            "default": 0
          }
        },
        "type": "object",
        "title": "ListBucketsRequest",
        "description": "Request model for listing buckets."
      },
      "ListBucketsResponse": {
        "properties": {
          "results": {
            "items": {
              "$ref": "#/components/schemas/BucketResponse"
            },
            "type": "array",
            "title": "Results"
          },
          "total_count": {
            "type": "integer",
            "title": "Total Count",
            "description": "Total number of buckets matching the query"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationResponse"
          }
        },
        "type": "object",
        "required": [
          "results",
          "total_count",
          "pagination"
        ],
        "title": "ListBucketsResponse",
        "description": "Response model for listing buckets."
      },
      "ListClustersRequest": {
        "properties": {
          "filters": {
            "description": "Filters to apply when listing clusters",
            "$ref": "#/components/schemas/LogicalOperator-Input",
            "nullable": true
          },
          "sort": {
            "description": "Sort options for the results",
            "$ref": "#/components/schemas/SortOption",
            "nullable": true
          },
          "search": {
            "title": "Search",
            "description": "Search query for filtering clusters",
            "type": "string",
            "nullable": true
          }
        },
        "type": "object",
        "title": "ListClustersRequest",
        "description": "Request model for listing clusters."
      },
      "ListClustersResponse": {
        "properties": {
          "results": {
            "items": {
              "$ref": "#/components/schemas/ClusterModel"
            },
            "type": "array",
            "title": "Results",
            "description": "List of cluster models"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationResponse",
            "description": "Pagination information"
          }
        },
        "type": "object",
        "required": [
          "results",
          "pagination"
        ],
        "title": "ListClustersResponse",
        "description": "Response model for listing clusters."
      },
      "ListCollectionsRequest": {
        "properties": {
          "filters": {
            "description": "Filters to apply when listing collections",
            "$ref": "#/components/schemas/LogicalOperator-Input",
            "nullable": true
          },
          "sort": {
            "description": "Sort options for the results",
            "$ref": "#/components/schemas/SortOption",
            "nullable": true
          },
          "search": {
            "title": "Search",
            "description": "Search query for filtering collections",
            "type": "string",
            "nullable": true
          },
          "case_sensitive": {
            "type": "boolean",
            "title": "Case Sensitive",
            "description": "If True, filters and search will be case-sensitive",
            "default": false
          }
        },
        "type": "object",
        "title": "ListCollectionsRequest",
        "description": "Request model for listing collections."
      },
      "ListCollectionsResponse": {
        "properties": {
          "results": {
            "items": {
              "$ref": "#/components/schemas/CollectionResponse"
            },
            "type": "array",
            "title": "Results",
            "description": "List of collections"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationResponse",
            "description": "Pagination information"
          },
          "total_count": {
            "type": "integer",
            "title": "Total Count",
            "description": "Total number of collections matching the query"
          }
        },
        "type": "object",
        "required": [
          "results",
          "pagination",
          "total_count"
        ],
        "title": "ListCollectionsResponse",
        "description": "Response model for listing collections."
      },
      "ListDocumentsRequest": {
        "properties": {
          "filters": {
            "description": "Filters to apply.",
            "$ref": "#/components/schemas/LogicalOperator-Input",
            "nullable": true
          },
          "sort": {
            "description": "Sort options.",
            "$ref": "#/components/schemas/SortOption",
            "nullable": true
          },
          "search": {
            "title": "Search",
            "description": "Search term.",
            "type": "string",
            "nullable": true
          },
          "return_url": {
            "title": "Return Url",
            "description": "Whether to return presigned URLs for object keys.",
            "default": false,
            "type": "boolean",
            "nullable": true
          },
          "return_vectors": {
            "title": "Return Vectors",
            "description": "Whether to return vector embeddings in the document results.",
            "default": false,
            "type": "boolean",
            "nullable": true
          }
        },
        "type": "object",
        "title": "ListDocumentsRequest",
        "description": "Request model for listing documents."
      },
      "ListDocumentsResponse": {
        "properties": {
          "results": {
            "items": {
              "$ref": "#/components/schemas/DocumentResponse"
            },
            "type": "array",
            "title": "Results"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationResponse"
          }
        },
        "type": "object",
        "required": [
          "results",
          "pagination"
        ],
        "title": "ListDocumentsResponse",
        "description": "Response model for listing documents."
      },
      "ListNamespacesRequest": {
        "properties": {
          "filters": {
            "title": "Filters",
            "description": "Optional filters to apply to the namespace list.",
            "example": {
              "description": "test",
              "namespace_name": {
                "$regex": "^my_namespace"
              }
            },
            "additionalProperties": true,
            "type": "object",
            "nullable": true
          },
          "sort": {
            "title": "Sort",
            "description": "Optional sort criteria for the namespace list.",
            "example": {
              "direction": "asc",
              "field": "namespace_name"
            },
            "additionalProperties": true,
            "type": "object",
            "nullable": true
          },
          "search": {
            "title": "Search",
            "description": "Search term for wildcard search across all text fields.",
            "example": "production",
            "type": "string",
            "nullable": true
          },
          "case_sensitive": {
            "type": "boolean",
            "title": "Case Sensitive",
            "description": "If True, filters and search will be case-sensitive",
            "default": false
          }
        },
        "type": "object",
        "title": "ListNamespacesRequest",
        "description": "Request schema for listing namespaces.",
        "examples": [
          {
            "filters": {
              "description": "test",
              "namespace_name": {
                "$regex": "^my_namespace"
              }
            },
            "sort": {
              "direction": "asc",
              "field": "namespace_name"
            }
          }
        ]
      },
      "ListNamespacesResponse": {
        "properties": {
          "results": {
            "items": {
              "$ref": "#/components/schemas/NamespaceModel"
            },
            "type": "array",
            "title": "Results",
            "description": "List of namespaces matching the query"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationResponse",
            "description": "Pagination information for the current result window"
          },
          "total_count": {
            "type": "integer",
            "title": "Total Count",
            "description": "Total number of namespaces that match the query"
          }
        },
        "type": "object",
        "required": [
          "results",
          "pagination",
          "total_count"
        ],
        "title": "ListNamespacesResponse",
        "description": "Response schema for listing namespaces.",
        "examples": [
          {
            "pagination": {
              "has_more": false,
              "limit": 10,
              "skip": 0
            },
            "results": [
              {
                "created_at": "2024-01-15T10:30:00Z",
                "description": "This namespace contains playlists from Spotify",
                "feature_extractors": [
                  {
                    "feature_extractor_name": "video_extractor",
                    "version": "1.0.0"
                  }
                ],
                "namespace_id": "ns_ab12cd34ef",
                "namespace_name": "spotify_playlists_dev",
                "payload_indexes": [
                  {
                    "field_name": "metadata.title",
                    "type": "text"
                  }
                ],
                "updated_at": "2024-01-15T10:30:00Z"
              }
            ],
            "total_count": 1
          }
        ]
      },
      "ListObjectsResponse": {
        "properties": {
          "results": {
            "items": {
              "$ref": "#/components/schemas/ObjectResponse"
            },
            "type": "array",
            "title": "Results",
            "description": "List of objects matching the query"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationResponse",
            "description": "Pagination information"
          }
        },
        "type": "object",
        "required": [
          "results",
          "pagination"
        ],
        "title": "ListObjectsResponse",
        "description": "Response model for listing objects in a bucket.",
        "examples": [
          {
            "pagination": {
              "has_more": false,
              "limit": 10,
              "skip": 0
            },
            "results": [
              {
                "blobs": [],
                "bucket_id": "bkt_9xy8z7",
                "key_prefix": "/contract-2024",
                "metadata": {
                  "category": "contracts",
                  "year": 2024
                },
                "object_id": "obj_123abc456def",
                "status": "DRAFT"
              }
            ]
          }
        ]
      },
      "ListRetrieversRequest": {
        "properties": {
          "filters": {
            "description": "Filters to apply when listing retrievers",
            "$ref": "#/components/schemas/LogicalOperator-Input",
            "nullable": true
          },
          "sorts": {
            "title": "Sorts",
            "description": "Sorting options for the retriever list",
            "items": {
              "$ref": "#/components/schemas/SortOption"
            },
            "type": "array",
            "nullable": true
          },
          "search": {
            "title": "Search",
            "description": "Search term for wildcard search across all text fields",
            "type": "string",
            "nullable": true
          },
          "case_sensitive": {
            "type": "boolean",
            "title": "Case Sensitive",
            "description": "If True, filters and search will be case-sensitive",
            "default": false
          },
          "limit": {
            "type": "integer",
            "maximum": 100.0,
            "minimum": 1.0,
            "title": "Limit",
            "description": "Pagination limit",
            "default": 10
          },
          "offset": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Offset",
            "description": "Pagination offset",
            "default": 0
          }
        },
        "type": "object",
        "title": "ListRetrieversRequest",
        "description": "List of retriever requests.",
        "examples": [
          {
            "filters": {
              "retriever_name": {
                "$regex": "product_"
              }
            },
            "limit": 10,
            "offset": 0,
            "sorts": [
              {
                "direction": "desc",
                "field": "created_at"
              }
            ]
          }
        ]
      },
      "ListRetrieversResponse": {
        "properties": {
          "results": {
            "items": {
              "$ref": "#/components/schemas/RetrieverModel-Output"
            },
            "type": "array",
            "title": "Results",
            "description": "List of retrievers matching the query"
          },
          "pagination": {
            "additionalProperties": true,
            "type": "object",
            "title": "Pagination",
            "description": "Pagination information for the current window"
          },
          "total_count": {
            "type": "integer",
            "title": "Total Count",
            "description": "Total number of retrievers that match the query"
          }
        },
        "type": "object",
        "required": [
          "results",
          "pagination",
          "total_count"
        ],
        "title": "ListRetrieversResponse",
        "description": "Response for listing retrievers.",
        "examples": [
          {
            "pagination": {
              "has_more": false,
              "limit": 10,
              "skip": 0
            },
            "results": [
              {
                "collection_ids": [
                  "col_products_v1"
                ],
                "metadata": {},
                "retriever_id": "ret_abc123",
                "retriever_name": "product_search_v1",
                "stages": []
              }
            ],
            "total_count": 1
          }
        ]
      },
      "ListTasksResponse": {
        "properties": {
          "results": {
            "items": {
              "$ref": "#/components/schemas/TaskResponse"
            },
            "type": "array",
            "title": "Results"
          },
          "pagination": {
            "$ref": "#/components/schemas/PaginationResponse"
          }
        },
        "type": "object",
        "required": [
          "results",
          "pagination"
        ],
        "title": "ListTasksResponse",
        "description": "Response model for listing tasks."
      },
      "ListTaxonomiesRequest": {
        "properties": {
          "search": {
            "title": "Search",
            "description": "Search term to filter taxonomies by name",
            "type": "string",
            "nullable": true
          },
          "filters": {
            "description": "Filters to apply to the taxonomy list",
            "$ref": "#/components/schemas/LogicalOperator-Input",
            "nullable": true
          },
          "sort": {
            "description": "Sort configuration for the taxonomy list",
            "$ref": "#/components/schemas/SortOption",
            "nullable": true
          },
          "case_sensitive": {
            "type": "boolean",
            "title": "Case Sensitive",
            "description": "If True, filters and search will be case-sensitive",
            "default": false
          }
        },
        "type": "object",
        "title": "ListTaxonomiesRequest",
        "description": "Request model to list taxonomies."
      },
      "ListTaxonomiesResponse": {
        "properties": {
          "results": {
            "items": {
              "$ref": "#/components/schemas/TaxonomyResponse"
            },
            "type": "array",
            "title": "Results"
          },
          "pagination": {
            "additionalProperties": true,
            "type": "object",
            "title": "Pagination"
          },
          "total_count": {
            "type": "integer",
            "title": "Total Count"
          }
        },
        "type": "object",
        "required": [
          "results",
          "pagination",
          "total_count"
        ],
        "title": "ListTaxonomiesResponse",
        "description": "Response model for listing taxonomies."
      },
      "ListTriggersRequest": {
        "properties": {
          "cluster_id": {
            "title": "Cluster Id",
            "description": "Filter by cluster ID",
            "type": "string",
            "nullable": true
          },
          "trigger_type": {
            "description": "Filter by trigger type",
            "$ref": "#/components/schemas/TriggerType",
            "nullable": true
          },
          "status": {
            "description": "Filter by status",
            "$ref": "#/components/schemas/TriggerStatus",
            "nullable": true
          },
          "offset": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Offset",
            "description": "Pagination offset",
            "default": 0
          },
          "limit": {
            "type": "integer",
            "maximum": 1000.0,
            "minimum": 1.0,
            "title": "Limit",
            "description": "Results per page",
            "default": 50
          },
          "sort_by": {
            "type": "string",
            "title": "Sort By",
            "description": "Field to sort by",
            "default": "created_at"
          },
          "direction": {
            "type": "string",
            "title": "Direction",
            "description": "Sort direction (asc/desc)",
            "default": "desc"
          }
        },
        "type": "object",
        "title": "ListTriggersRequest",
        "description": "Request to list triggers with filters and pagination."
      },
      "ListTriggersResponse": {
        "properties": {
          "triggers": {
            "items": {
              "$ref": "#/components/schemas/TriggerModel"
            },
            "type": "array",
            "title": "Triggers",
            "description": "List of triggers"
          },
          "total": {
            "type": "integer",
            "title": "Total",
            "description": "Total number of triggers"
          },
          "offset": {
            "type": "integer",
            "title": "Offset",
            "description": "Current offset"
          },
          "limit": {
            "type": "integer",
            "title": "Limit",
            "description": "Current limit"
          }
        },
        "type": "object",
        "required": [
          "triggers",
          "total",
          "offset",
          "limit"
        ],
        "title": "ListTriggersResponse",
        "description": "Response for list triggers request."
      },
      "LogicalOperator-Input": {
        "properties": {
          "AND": {
            "title": "And",
            "description": "Logical AND operation - all conditions must be true",
            "example": [
              {
                "field": "name",
                "operator": "eq",
                "value": "John"
              },
              {
                "field": "age",
                "operator": "gte",
                "value": 30
              }
            ],
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/LogicalOperator-Input"
                },
                {
                  "$ref": "#/components/schemas/FilterCondition"
                }
              ]
            },
            "type": "array",
            "nullable": true
          },
          "OR": {
            "title": "Or",
            "description": "Logical OR operation - at least one condition must be true",
            "example": [
              {
                "field": "status",
                "operator": "eq",
                "value": "active"
              },
              {
                "field": "role",
                "operator": "eq",
                "value": "admin"
              }
            ],
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/LogicalOperator-Input"
                },
                {
                  "$ref": "#/components/schemas/FilterCondition"
                }
              ]
            },
            "type": "array",
            "nullable": true
          },
          "NOT": {
            "title": "Not",
            "description": "Logical NOT operation - all conditions must be false",
            "example": [
              {
                "field": "department",
                "operator": "eq",
                "value": "HR"
              },
              {
                "field": "location",
                "operator": "eq",
                "value": "remote"
              }
            ],
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/LogicalOperator-Input"
                },
                {
                  "$ref": "#/components/schemas/FilterCondition"
                }
              ]
            },
            "type": "array",
            "nullable": true
          },
          "case_sensitive": {
            "title": "Case Sensitive",
            "description": "Whether to perform case-sensitive matching",
            "default": false,
            "example": true,
            "type": "boolean",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "type": "object",
        "title": "LogicalOperator",
        "description": "Represents a logical operation (AND, OR, NOT) on filter conditions.\n\nAllows nesting with a defined depth limit."
      },
      "LogicalOperator-Output": {
        "properties": {
          "AND": {
            "title": "And",
            "description": "Logical AND operation - all conditions must be true",
            "example": [
              {
                "field": "name",
                "operator": "eq",
                "value": "John"
              },
              {
                "field": "age",
                "operator": "gte",
                "value": 30
              }
            ],
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/LogicalOperator-Output"
                },
                {
                  "$ref": "#/components/schemas/FilterCondition"
                }
              ]
            },
            "type": "array",
            "nullable": true
          },
          "OR": {
            "title": "Or",
            "description": "Logical OR operation - at least one condition must be true",
            "example": [
              {
                "field": "status",
                "operator": "eq",
                "value": "active"
              },
              {
                "field": "role",
                "operator": "eq",
                "value": "admin"
              }
            ],
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/LogicalOperator-Output"
                },
                {
                  "$ref": "#/components/schemas/FilterCondition"
                }
              ]
            },
            "type": "array",
            "nullable": true
          },
          "NOT": {
            "title": "Not",
            "description": "Logical NOT operation - all conditions must be false",
            "example": [
              {
                "field": "department",
                "operator": "eq",
                "value": "HR"
              },
              {
                "field": "location",
                "operator": "eq",
                "value": "remote"
              }
            ],
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/LogicalOperator-Output"
                },
                {
                  "$ref": "#/components/schemas/FilterCondition"
                }
              ]
            },
            "type": "array",
            "nullable": true
          },
          "case_sensitive": {
            "title": "Case Sensitive",
            "description": "Whether to perform case-sensitive matching",
            "default": false,
            "example": true,
            "type": "boolean",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "type": "object",
        "title": "LogicalOperator",
        "description": "Represents a logical operation (AND, OR, NOT) on filter conditions.\n\nAllows nesting with a defined depth limit."
      },
      "MeanShiftParams": {
        "properties": {
          "bandwidth": {
            "title": "Bandwidth",
            "description": "Bandwidth used in the RBF kernel. If None, estimated using sklearn.cluster.estimate_bandwidth",
            "type": "number",
            "exclusiveMinimum": 0.0,
            "nullable": true
          },
          "seeds": {
            "title": "Seeds",
            "description": "Seeds used to initialize kernels. If None, all points are used as seeds",
            "items": {
              "items": {
                "type": "number"
              },
              "type": "array"
            },
            "type": "array",
            "nullable": true
          },
          "bin_seeding": {
            "type": "boolean",
            "title": "Bin Seeding",
            "description": "If true, initial kernel locations are discretized into a grid to speed up algorithm",
            "default": false
          },
          "min_bin_freq": {
            "type": "integer",
            "minimum": 1.0,
            "title": "Min Bin Freq",
            "description": "Minimum number of seeds within a bin for the bin to be considered",
            "default": 1
          },
          "cluster_all": {
            "type": "boolean",
            "title": "Cluster All",
            "description": "If true, all points are clustered, even orphans. If false, orphans are given label -1",
            "default": true
          },
          "n_jobs": {
            "type": "integer",
            "title": "N Jobs",
            "description": "Number of parallel jobs to run (-1 means using all processors)",
            "default": 1
          },
          "max_iter": {
            "type": "integer",
            "minimum": 1.0,
            "title": "Max Iter",
            "description": "Maximum number of iterations per seed point before the algorithm stops",
            "default": 300
          }
        },
        "type": "object",
        "title": "MeanShiftParams",
        "description": "Parameters for Mean Shift clustering algorithm."
      },
      "MultiDenseVector": {
        "properties": {},
        "additionalProperties": true,
        "type": "object",
        "title": "MultiDenseVector",
        "description": "Multi-dimensional dense vector representation with flexible key naming.\n\nAccepts a single key-value pair where the key can be any string\nand the value must be a list of lists of floats.\nUseful for late interaction models and other multi-dimensional embeddings.\n\nExample:\n```json\n{\n    \"embeddings\": [\n        [0.1, 0.2, 0.3],\n        [0.4, 0.5, 0.6],\n        [0.7, 0.8, 0.9]\n    ]\n}\n```\nor\n```json\n{\n    \"multi_vectors\": [\n        [0.1, 0.2, 0.3],\n        [0.4, 0.5, 0.6],\n        [0.7, 0.8, 0.9]\n    ]\n}\n```"
      },
      "MultiVectorIndex": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Name"
          },
          "description": {
            "type": "string",
            "title": "Description"
          },
          "vectors": {
            "additionalProperties": {
              "$ref": "#/components/schemas/VectorIndex"
            },
            "type": "object",
            "title": "Vectors"
          }
        },
        "type": "object",
        "required": [
          "name",
          "description",
          "vectors"
        ],
        "title": "MultiVectorIndex",
        "description": "Configuration for multi-vector indexes."
      },
      "NamedDenseVectors": {
        "additionalProperties": {
          "items": {
            "type": "number"
          },
          "type": "array"
        },
        "type": "object",
        "title": "NamedDenseVectors",
        "description": "Root model mapping vector names \u2192 dense float lists.\n\nAccepts JSON like:\n```json\n{\n    \"vector_a\": [0.1, 0.2, 0.3],\n    \"vector_b\": [0.4, 0.5, 0.6]\n}\n```"
      },
      "NamespaceModel": {
        "properties": {
          "namespace_id": {
            "type": "string",
            "title": "Namespace Id",
            "description": "Unique identifier for the namespace"
          },
          "namespace_name": {
            "type": "string",
            "title": "Namespace Name",
            "description": "Name of the namespace",
            "example": "spotify_playlists_dev"
          },
          "description": {
            "title": "Description",
            "description": "Description of the namespace",
            "type": "string",
            "nullable": true
          },
          "feature_extractors": {
            "items": {
              "$ref": "#/components/schemas/BaseFeatureExtractorModel-Output"
            },
            "type": "array",
            "title": "Feature Extractors",
            "description": "List of feature extractors configured for this namespace"
          },
          "payload_indexes": {
            "title": "Payload Indexes",
            "description": "Custom payload indexes configured for this namespace",
            "items": {
              "$ref": "#/components/schemas/PayloadIndexConfig-Output"
            },
            "type": "array",
            "nullable": true
          },
          "created_at": {
            "title": "Created At",
            "description": "When the namespace was created",
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "updated_at": {
            "title": "Updated At",
            "description": "When the namespace was last updated",
            "type": "string",
            "format": "date-time",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "namespace_name"
        ],
        "title": "NamespaceModel",
        "description": "Namespace model."
      },
      "NoReduction": {
        "properties": {
          "method": {
            "type": "string",
            "const": "none",
            "title": "Method",
            "default": "none"
          }
        },
        "type": "object",
        "title": "NoReduction"
      },
      "NotificationChannel": {
        "type": "string",
        "enum": [
          "email",
          "slack",
          "webhook",
          "sms"
        ],
        "title": "NotificationChannel",
        "description": "Enum for notification delivery channels."
      },
      "NotificationContentType": {
        "type": "string",
        "enum": [
          "plain_text",
          "html",
          "markdown",
          "json"
        ],
        "title": "NotificationContentType",
        "description": "Enum for content formats."
      },
      "OPTICSParams": {
        "properties": {
          "min_samples": {
            "type": "integer",
            "minimum": 2.0,
            "title": "Min Samples",
            "description": "Number of samples in a neighborhood for a point to be considered a core point",
            "default": 5
          },
          "max_eps": {
            "title": "Max Eps",
            "description": "Maximum distance between two samples. Default (None) means no maximum distance",
            "type": "number",
            "exclusiveMinimum": 0.0,
            "nullable": true
          },
          "metric": {
            "type": "string",
            "title": "Metric",
            "description": "Metric to use for distance computation",
            "default": "minkowski"
          },
          "p": {
            "type": "number",
            "exclusiveMinimum": 0.0,
            "title": "P",
            "description": "Parameter for the Minkowski metric",
            "default": 2
          },
          "metric_params": {
            "title": "Metric Params",
            "description": "Additional keyword arguments for the metric function",
            "additionalProperties": true,
            "type": "object",
            "nullable": true
          },
          "cluster_method": {
            "type": "string",
            "title": "Cluster Method",
            "description": "Method to extract clusters ('xi' or 'dbscan')",
            "default": "xi"
          },
          "eps": {
            "title": "Eps",
            "description": "Maximum distance for DBSCAN cluster extraction method",
            "type": "number",
            "exclusiveMinimum": 0.0,
            "nullable": true
          },
          "xi": {
            "type": "number",
            "maximum": 1.0,
            "minimum": 0.0,
            "title": "Xi",
            "description": "Minimum steepness on the reachability plot for cluster boundary (xi method)",
            "default": 0.05
          },
          "predecessor_correction": {
            "type": "boolean",
            "title": "Predecessor Correction",
            "description": "Correct clusters based on predecessors (xi method)",
            "default": true
          },
          "min_cluster_size": {
            "title": "Min Cluster Size",
            "description": "Minimum number of samples in a cluster. Can be a fraction if < 1.0",
            "type": "number",
            "nullable": true
          },
          "algorithm": {
            "type": "string",
            "title": "Algorithm",
            "description": "Algorithm to compute pointwise distances ('auto', 'ball_tree', 'kd_tree', 'brute')",
            "default": "auto"
          },
          "leaf_size": {
            "type": "integer",
            "minimum": 1.0,
            "title": "Leaf Size",
            "description": "Leaf size passed to BallTree or KDTree",
            "default": 30
          },
          "n_jobs": {
            "type": "integer",
            "title": "N Jobs",
            "description": "Number of parallel jobs to run (-1 means using all processors)",
            "default": 1
          }
        },
        "type": "object",
        "title": "OPTICSParams",
        "description": "Parameters for OPTICS clustering algorithm."
      },
      "ObjectResponse": {
        "properties": {
          "object_id": {
            "type": "string",
            "title": "Object Id",
            "description": "Unique identifier for the object"
          },
          "bucket_id": {
            "type": "string",
            "title": "Bucket Id",
            "description": "ID of the bucket this object belongs to"
          },
          "key_prefix": {
            "title": "Key Prefix",
            "description": "Storage key/path of the object, this will be used to retrieve the object from the storage. It is similar to a file path. If not provided, it will be placed in the root of the bucket.",
            "type": "string",
            "nullable": true
          },
          "content_hash": {
            "title": "Content Hash",
            "description": "SHA256 hash of the object's content, used for de-duplication.",
            "type": "string",
            "nullable": true
          },
          "blobs": {
            "items": {
              "$ref": "#/components/schemas/BlobModel"
            },
            "type": "array",
            "title": "Blobs",
            "description": "List of blobs contained in this object"
          },
          "source_details": {
            "items": {
              "$ref": "#/components/schemas/SourceDetails"
            },
            "type": "array",
            "title": "Source Details",
            "description": "Lineage/source details for this object; used for downstream references."
          },
          "metadata": {
            "additionalProperties": true,
            "type": "object",
            "title": "Metadata",
            "description": "Additional metadata for the object, this will be appended in all downstream documents of the your connected collections."
          },
          "status": {
            "$ref": "#/components/schemas/TaskStatusEnum",
            "description": "The current status of the object.",
            "default": "DRAFT"
          },
          "error": {
            "title": "Error",
            "description": "The error message if the object failed to process.",
            "examples": [
              "Failed to process object: Object not found"
            ],
            "type": "string",
            "nullable": true
          },
          "skip_duplicates": {
            "type": "boolean",
            "title": "Skip Duplicates",
            "description": "Skip duplicate blobs, if a blob with the same hash already exists, it will be skipped.",
            "default": false
          }
        },
        "type": "object",
        "required": [
          "bucket_id"
        ],
        "title": "ObjectResponse",
        "description": "Response model for bucket objects.",
        "examples": [
          {
            "blobs": [
              {
                "blob_id": "blob_1",
                "data": {
                  "num_pages": 5,
                  "title": "Service Agreement 2024"
                },
                "key_prefix": "/contract-2024/content.pdf",
                "metadata": {
                  "author": "John Doe",
                  "department": "Legal"
                },
                "property": "content",
                "type": "PDF"
              }
            ],
            "bucket_id": "bkt_9xy8z7",
            "content_hash": "28a9f5e8...",
            "key_prefix": "/contract-2024",
            "metadata": {
              "category": "contracts",
              "year": 2024
            },
            "object_id": "obj_123abc456def",
            "skip_duplicates": false,
            "status": "DRAFT"
          }
        ]
      },
      "OrganizationAdminUpdateRequest": {
        "properties": {
          "account_type": {
            "$ref": "#/components/schemas/AccountTier",
            "nullable": true
          },
          "rate_limits": {
            "$ref": "#/components/schemas/BaseRateLimits",
            "nullable": true
          }
        },
        "type": "object",
        "title": "OrganizationAdminUpdateRequest",
        "description": "Admin-only update request for organizations.\n\nAllows changing the account tier and overriding rate limits."
      },
      "OrganizationModelResponse": {
        "properties": {
          "internal_id": {
            "type": "string",
            "title": "Internal Id"
          },
          "organization_name": {
            "type": "string",
            "title": "Organization Name"
          },
          "organization_id": {
            "type": "string",
            "title": "Organization Id"
          },
          "account_type": {
            "$ref": "#/components/schemas/AccountTier"
          },
          "credit_count": {
            "type": "integer",
            "title": "Credit Count"
          },
          "metadata": {
            "additionalProperties": true,
            "type": "object",
            "title": "Metadata"
          },
          "users": {
            "items": {
              "$ref": "#/components/schemas/UserModel-Output"
            },
            "type": "array",
            "title": "Users"
          },
          "rate_limits": {
            "$ref": "#/components/schemas/BaseRateLimits"
          }
        },
        "type": "object",
        "required": [
          "internal_id",
          "organization_name",
          "organization_id",
          "account_type",
          "credit_count",
          "metadata",
          "users",
          "rate_limits"
        ],
        "title": "OrganizationModelResponse",
        "description": "Organization Model."
      },
      "PaginationResponse": {
        "properties": {
          "total": {
            "type": "integer",
            "title": "Total"
          },
          "page": {
            "type": "integer",
            "title": "Page"
          },
          "page_size": {
            "type": "integer",
            "title": "Page Size"
          },
          "total_pages": {
            "type": "integer",
            "title": "Total Pages"
          },
          "next_page": {
            "title": "Next Page",
            "type": "string",
            "nullable": true
          },
          "previous_page": {
            "title": "Previous Page",
            "type": "string",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "total",
          "page",
          "page_size",
          "total_pages"
        ],
        "title": "PaginationResponse",
        "description": "PaginationResponse."
      },
      "ParameterConfig": {
        "properties": {
          "type": {
            "$ref": "#/components/schemas/ParameterType",
            "description": "The type of the parameter (e.g., 'fixed')."
          },
          "value": {
            "title": "Value",
            "description": "The value of the parameter."
          }
        },
        "type": "object",
        "required": [
          "type",
          "value"
        ],
        "title": "ParameterConfig",
        "description": "A typed value for a feature extractor parameter."
      },
      "ParameterType": {
        "type": "string",
        "enum": [
          "fixed",
          "dynamic"
        ],
        "title": "ParameterType",
        "description": "The type of a feature extractor parameter.\n\n- 'fixed': The value is provided directly.\n- 'dynamic': The value is resolved from the input data via mapping."
      },
      "PayloadIndexConfig-Input": {
        "properties": {
          "field_name": {
            "type": "string",
            "title": "Field Name"
          },
          "type": {
            "$ref": "#/components/schemas/PayloadSchemaType"
          },
          "field_schema": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/TextIndexParams"
              },
              {
                "$ref": "#/components/schemas/IntegerIndexParams"
              },
              {
                "$ref": "#/components/schemas/KeywordIndexParams"
              },
              {
                "$ref": "#/components/schemas/FloatIndexParams"
              },
              {
                "$ref": "#/components/schemas/GeoIndexParams"
              },
              {
                "$ref": "#/components/schemas/DatetimeIndexParams"
              },
              {
                "$ref": "#/components/schemas/UuidIndexParams"
              },
              {
                "$ref": "#/components/schemas/BoolIndexParams"
              }
            ],
            "title": "Field Schema",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "field_name",
          "type"
        ],
        "title": "PayloadIndexConfig",
        "description": "Configuration for a payload index."
      },
      "PayloadIndexConfig-Output": {
        "properties": {
          "field_name": {
            "type": "string",
            "title": "Field Name"
          },
          "type": {
            "$ref": "#/components/schemas/PayloadSchemaType"
          },
          "field_schema": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/TextIndexParams"
              },
              {
                "$ref": "#/components/schemas/IntegerIndexParams"
              },
              {
                "$ref": "#/components/schemas/KeywordIndexParams"
              },
              {
                "$ref": "#/components/schemas/FloatIndexParams"
              },
              {
                "$ref": "#/components/schemas/GeoIndexParams"
              },
              {
                "$ref": "#/components/schemas/DatetimeIndexParams"
              },
              {
                "$ref": "#/components/schemas/UuidIndexParams"
              },
              {
                "$ref": "#/components/schemas/BoolIndexParams"
              }
            ],
            "title": "Field Schema",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "field_name",
          "type"
        ],
        "title": "PayloadIndexConfig",
        "description": "Configuration for a payload index."
      },
      "PayloadSchemaType": {
        "type": "string",
        "enum": [
          "keyword",
          "integer",
          "float",
          "bool",
          "geo",
          "datetime",
          "text",
          "uuid"
        ],
        "title": "PayloadSchemaType",
        "description": "Payload schema type."
      },
      "Permission": {
        "type": "string",
        "enum": [
          "read",
          "write",
          "view",
          "create",
          "update",
          "delete",
          "super",
          "admin",
          "manage_users",
          "manage_billing",
          "manage_settings",
          "read_public",
          "read_private",
          "write_public",
          "write_private"
        ],
        "title": "Permission",
        "description": "Permission."
      },
      "PresignedURLModel": {
        "properties": {
          "key_name": {
            "type": "string",
            "title": "Key Name",
            "description": "Logical name or filename, e.g., 'thumb.jpg'"
          },
          "object_key": {
            "type": "string",
            "title": "Object Key",
            "description": "Full S3 object key"
          },
          "presigned_url": {
            "type": "string",
            "minLength": 1,
            "format": "uri",
            "title": "Presigned Url",
            "description": "Time-limited HTTPS URL"
          }
        },
        "type": "object",
        "required": [
          "key_name",
          "object_key",
          "presigned_url"
        ],
        "title": "PresignedURLModel",
        "description": "Typed presigned URL entry for a related S3 object."
      },
      "RetrieverModel-Input": {
        "properties": {
          "retriever_id": {
            "type": "string",
            "title": "Retriever Id",
            "description": "Unique identifier for the retriever"
          },
          "retriever_name": {
            "type": "string",
            "title": "Retriever Name",
            "description": "Name of the retriever"
          },
          "description": {
            "title": "Description",
            "description": "Description of the retriever",
            "type": "string",
            "nullable": true
          },
          "input_schema": {
            "$ref": "#/components/schemas/RetrieverSchema-Input",
            "description": "Input schema for the retriever"
          },
          "collection_ids": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Collection Ids",
            "description": "List of collection IDs"
          },
          "stages": {
            "items": {
              "$ref": "#/components/schemas/StageInstanceConfig-Input"
            },
            "type": "array",
            "title": "Stages",
            "description": "List of stage configurations"
          },
          "cache_config": {
            "description": "Cache configuration for this retriever. If not provided, caching is disabled.",
            "$ref": "#/components/schemas/CacheConfig",
            "nullable": true
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At",
            "description": "When the retriever was created"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Updated At",
            "description": "When the retriever was last modified"
          },
          "last_executed_at": {
            "title": "Last Executed At",
            "description": "When the retriever was last executed",
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "enabled": {
            "type": "boolean",
            "title": "Enabled",
            "description": "Whether the retriever is enabled (can be toggled on/off)",
            "default": true
          },
          "status": {
            "$ref": "#/components/schemas/RetrieverStatus",
            "description": "Current operational status",
            "default": "active"
          },
          "usage_stats": {
            "description": "Usage and performance statistics",
            "$ref": "#/components/schemas/UsageStatistics",
            "nullable": true
          },
          "collections": {
            "title": "Collections",
            "description": "Expanded collection details with names and metadata",
            "items": {
              "$ref": "#/components/schemas/CollectionDetail"
            },
            "type": "array",
            "nullable": true
          },
          "metadata": {
            "additionalProperties": true,
            "type": "object",
            "title": "Metadata",
            "description": "Custom key-value metadata"
          },
          "tags": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Tags",
            "description": "Tags for organization and filtering"
          },
          "created_by": {
            "description": "Information about who created this retriever",
            "$ref": "#/components/schemas/CreatorInfo",
            "nullable": true
          },
          "updated_by": {
            "description": "Information about who last updated this retriever",
            "$ref": "#/components/schemas/CreatorInfo",
            "nullable": true
          },
          "version": {
            "type": "integer",
            "title": "Version",
            "description": "Version number (increments on each update)",
            "default": 1
          },
          "revision_history": {
            "items": {
              "$ref": "#/components/schemas/RevisionHistoryEntry"
            },
            "type": "array",
            "title": "Revision History",
            "description": "History of changes (optional, last N changes)"
          },
          "health": {
            "description": "Health status and diagnostics",
            "$ref": "#/components/schemas/HealthCheck-Input",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "retriever_name",
          "input_schema",
          "collection_ids",
          "stages"
        ],
        "title": "RetrieverModel",
        "description": "Retriever model."
      },
      "RetrieverModel-Output": {
        "properties": {
          "retriever_id": {
            "type": "string",
            "title": "Retriever Id",
            "description": "Unique identifier for the retriever"
          },
          "retriever_name": {
            "type": "string",
            "title": "Retriever Name",
            "description": "Name of the retriever"
          },
          "description": {
            "title": "Description",
            "description": "Description of the retriever",
            "type": "string",
            "nullable": true
          },
          "input_schema": {
            "$ref": "#/components/schemas/RetrieverSchema-Output",
            "description": "Input schema for the retriever"
          },
          "collection_ids": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Collection Ids",
            "description": "List of collection IDs"
          },
          "stages": {
            "items": {
              "$ref": "#/components/schemas/StageInstanceConfig-Output"
            },
            "type": "array",
            "title": "Stages",
            "description": "List of stage configurations"
          },
          "cache_config": {
            "description": "Cache configuration for this retriever. If not provided, caching is disabled.",
            "$ref": "#/components/schemas/CacheConfig",
            "nullable": true
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At",
            "description": "When the retriever was created"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Updated At",
            "description": "When the retriever was last modified"
          },
          "last_executed_at": {
            "title": "Last Executed At",
            "description": "When the retriever was last executed",
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "enabled": {
            "type": "boolean",
            "title": "Enabled",
            "description": "Whether the retriever is enabled (can be toggled on/off)",
            "default": true
          },
          "status": {
            "$ref": "#/components/schemas/RetrieverStatus",
            "description": "Current operational status",
            "default": "active"
          },
          "usage_stats": {
            "description": "Usage and performance statistics",
            "$ref": "#/components/schemas/UsageStatistics",
            "nullable": true
          },
          "collections": {
            "title": "Collections",
            "description": "Expanded collection details with names and metadata",
            "items": {
              "$ref": "#/components/schemas/CollectionDetail"
            },
            "type": "array",
            "nullable": true
          },
          "metadata": {
            "additionalProperties": true,
            "type": "object",
            "title": "Metadata",
            "description": "Custom key-value metadata"
          },
          "tags": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Tags",
            "description": "Tags for organization and filtering"
          },
          "created_by": {
            "description": "Information about who created this retriever",
            "$ref": "#/components/schemas/CreatorInfo",
            "nullable": true
          },
          "updated_by": {
            "description": "Information about who last updated this retriever",
            "$ref": "#/components/schemas/CreatorInfo",
            "nullable": true
          },
          "version": {
            "type": "integer",
            "title": "Version",
            "description": "Version number (increments on each update)",
            "default": 1
          },
          "revision_history": {
            "items": {
              "$ref": "#/components/schemas/RevisionHistoryEntry"
            },
            "type": "array",
            "title": "Revision History",
            "description": "History of changes (optional, last N changes)"
          },
          "health": {
            "description": "Health status and diagnostics",
            "$ref": "#/components/schemas/HealthCheck-Output",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "retriever_name",
          "input_schema",
          "collection_ids",
          "stages"
        ],
        "title": "RetrieverModel",
        "description": "Retriever model."
      },
      "RetrieverQueryRequest": {
        "properties": {
          "retriever_id": {
            "title": "Retriever Id",
            "description": "Identifier of the retriever to execute. If omitted, the execution context must provide it.",
            "type": "string",
            "nullable": true
          },
          "inputs": {
            "additionalProperties": true,
            "type": "object",
            "title": "Inputs",
            "description": "Input values for the retriever query. These map to the required inputs defined in the retriever's first stage."
          },
          "filters": {
            "description": "Logical operations for filtering results. Can include AND, OR, NOT conditions with field comparisons.",
            "$ref": "#/components/schemas/LogicalOperator-Input",
            "nullable": true
          },
          "sorts": {
            "title": "Sorts",
            "description": "Controls the ordering of results. Can sort by score (default) or any other document field. This sorts the results from the last stage.",
            "items": {
              "$ref": "#/components/schemas/SortOption"
            },
            "type": "array",
            "nullable": true
          },
          "limit": {
            "type": "integer",
            "maximum": 100.0,
            "minimum": 1.0,
            "title": "Limit",
            "description": "Maximum number of results to return. Overrides the default pagination limit in the retriever definition.",
            "default": 10
          },
          "offset": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Offset",
            "description": "Number of results to skip. Use with limit for pagination. For large offsets, consider using session_id for cursor-based pagination.",
            "default": 0
          },
          "select": {
            "title": "Select",
            "description": "Specific fields to include in the response. If not specified, returns all fields.",
            "items": {
              "type": "string"
            },
            "type": "array",
            "nullable": true
          },
          "session_id": {
            "title": "Session Id",
            "description": "Session identifier for interaction tracking.",
            "type": "string",
            "nullable": true
          },
          "return_urls": {
            "type": "boolean",
            "title": "Return Urls",
            "description": "When true, generates pre-signed URLs for any media assets in the results. May increase response time slightly.",
            "default": false
          },
          "group_by": {
            "description": "Options for grouping results by a specific field.",
            "$ref": "#/components/schemas/GroupByOption",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "inputs"
        ],
        "title": "RetrieverQueryRequest",
        "description": "Query parameters for executing a retriever pipeline.\n\nThis model defines all the parameters that can be provided when running a\nsearch using a predefined retriever pipeline. It allows for customizing the\nquery inputs, filtering, sorting, pagination, and result formatting."
      },
      "RetrieverResponse": {
        "properties": {
          "execution_id": {
            "type": "string",
            "title": "Execution Id",
            "description": "Unique identifier for the retriever execution"
          },
          "execution_time": {
            "type": "number",
            "title": "Execution Time",
            "description": "Total execution time of the retriever pipeline.",
            "default": 0.0
          },
          "stage_results": {
            "items": {
              "$ref": "#/components/schemas/StageResponse"
            },
            "type": "array",
            "title": "Stage Results",
            "description": "Results from each stage of the retriever pipeline."
          },
          "final_results": {
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/DocumentResult"
                },
                {
                  "$ref": "#/components/schemas/GroupedResultItem"
                }
              ]
            },
            "type": "array",
            "title": "Final Results",
            "description": "Final sorted and paginated results of the retriever execution."
          }
        },
        "type": "object",
        "title": "RetrieverResponse",
        "description": "Response from a retriever execution."
      },
      "RetrieverSchema-Input": {
        "properties": {
          "properties": {
            "additionalProperties": {
              "$ref": "#/components/schemas/BucketSchemaField-Input"
            },
            "type": "object",
            "title": "Properties"
          }
        },
        "additionalProperties": true,
        "type": "object",
        "required": [
          "properties"
        ],
        "title": "RetrieverSchema",
        "description": "Schema definition for retriever inputs."
      },
      "RetrieverSchema-Output": {
        "properties": {
          "properties": {
            "additionalProperties": {
              "$ref": "#/components/schemas/BucketSchemaField-Output"
            },
            "type": "object",
            "title": "Properties"
          }
        },
        "additionalProperties": true,
        "type": "object",
        "required": [
          "properties"
        ],
        "title": "RetrieverSchema",
        "description": "Schema definition for retriever inputs."
      },
      "RetrieverStageDefinition": {
        "properties": {
          "stage_name": {
            "type": "string",
            "title": "Stage Name",
            "description": "The unique name of the stage."
          },
          "version": {
            "type": "string",
            "title": "Version",
            "description": "The version of the stage."
          },
          "description": {
            "type": "string",
            "title": "Description",
            "description": "A description of what the stage does."
          },
          "parameter_schema": {
            "title": "Parameter Schema",
            "description": "The schema for the parameters this stage accepts.",
            "additionalProperties": true,
            "type": "object",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "stage_name",
          "version",
          "description"
        ],
        "title": "RetrieverStageDefinition",
        "description": "Public definition of a retriever stage.",
        "examples": [
          {
            "description": "Performs KNN search over a configured vector field",
            "parameter_schema": {
              "k": {
                "default": 10,
                "minimum": 1,
                "type": "integer"
              },
              "vector_field": {
                "type": "string"
              }
            },
            "stage_name": "knn_search",
            "version": "1.0.0"
          }
        ]
      },
      "RetrieverStatus": {
        "type": "string",
        "enum": [
          "active",
          "draft",
          "disabled",
          "error"
        ],
        "title": "RetrieverStatus",
        "description": "Status of a retriever."
      },
      "RevisionHistoryEntry": {
        "properties": {
          "version": {
            "type": "integer",
            "title": "Version",
            "description": "Version number"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Updated At",
            "description": "When this version was created"
          },
          "updated_by": {
            "title": "Updated By",
            "description": "User who made the change",
            "type": "string",
            "nullable": true
          },
          "changes": {
            "title": "Changes",
            "description": "Description of changes made",
            "type": "string",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "version",
          "updated_at"
        ],
        "title": "RevisionHistoryEntry",
        "description": "A single entry in the revision history."
      },
      "SingleLineageEntry": {
        "properties": {
          "source_config": {
            "$ref": "#/components/schemas/SourceConfig",
            "description": "Configuration of the source for this lineage entry"
          },
          "feature_extractors": {
            "items": {
              "$ref": "#/components/schemas/FeatureExtractorConfig-Output"
            },
            "type": "array",
            "title": "Feature Extractors",
            "description": "Feature extractors applied at this stage"
          },
          "output_schema": {
            "$ref": "#/components/schemas/BucketSchema-Output",
            "description": "Output schema produced by this processing stage"
          }
        },
        "type": "object",
        "required": [
          "source_config",
          "output_schema"
        ],
        "title": "SingleLineageEntry",
        "description": "Single entry in the lineage chain of a collection."
      },
      "SlackConfig": {
        "properties": {
          "webhook_url": {
            "type": "string",
            "title": "Webhook Url",
            "description": "Slack webhook URL"
          },
          "channel": {
            "title": "Channel",
            "description": "Slack channel to send to",
            "type": "string",
            "nullable": true
          },
          "username": {
            "title": "Username",
            "description": "Username to use for the message",
            "type": "string",
            "nullable": true
          },
          "icon_emoji": {
            "title": "Icon Emoji",
            "description": "Emoji to use as the icon",
            "type": "string",
            "nullable": true
          },
          "icon_url": {
            "title": "Icon Url",
            "description": "URL to an image to use as the icon",
            "type": "string",
            "nullable": true
          },
          "blocks_template": {
            "title": "Blocks Template",
            "description": "Template for Slack blocks",
            "type": "string",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "webhook_url"
        ],
        "title": "SlackConfig",
        "description": "Configuration for Slack notifications."
      },
      "SmsConfig": {
        "properties": {
          "phone_numbers": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Phone Numbers",
            "description": "Phone numbers to send to"
          },
          "message_template": {
            "title": "Message Template",
            "description": "Template for SMS message",
            "type": "string",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "phone_numbers"
        ],
        "title": "SmsConfig",
        "description": "Configuration for SMS notifications."
      },
      "SortDirection": {
        "type": "string",
        "enum": [
          "asc",
          "desc"
        ],
        "title": "SortDirection",
        "description": "Sort direction options."
      },
      "SortOption": {
        "properties": {
          "field": {
            "type": "string",
            "title": "Field",
            "description": "Field to sort by, supports dot notation for nested fields",
            "example": "created_at"
          },
          "direction": {
            "$ref": "#/components/schemas/SortDirection",
            "description": "Sort direction",
            "default": "asc",
            "example": "desc"
          }
        },
        "type": "object",
        "required": [
          "field"
        ],
        "title": "SortOption",
        "description": "Specifies how to sort query results.\n\nAttributes:\n    field: Field to sort by\n    direction: Sort direction (ascending or descending)"
      },
      "SourceCollection-Input": {
        "properties": {
          "collection_id": {
            "type": "string",
            "title": "Collection Id",
            "description": "The ID of the source collection for the taxonomy."
          },
          "enrichment_fields": {
            "title": "Enrichment Fields",
            "description": "Fields to copy from matched taxonomy node when enriching (append/replace semantics). If omitted, the full payload is copied.",
            "items": {
              "$ref": "#/components/schemas/EnrichmentField"
            },
            "type": "array",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "collection_id"
        ],
        "title": "SourceCollection",
        "description": "A source collection for a flat taxonomy.",
        "examples": [
          {
            "collection_id": "col_products_v1",
            "enrichment_fields": [
              {
                "field_path": "metadata.tags",
                "merge_mode": "append"
              }
            ],
            "input_mappings": [
              {
                "input_key": "image_vector",
                "path": "features.clip_vit_l_14",
                "source_type": "vector"
              }
            ],
            "retriever_id": "ret_clip_v1"
          }
        ]
      },
      "SourceCollection-Output": {
        "properties": {
          "collection_id": {
            "type": "string",
            "title": "Collection Id",
            "description": "The ID of the source collection for the taxonomy."
          },
          "enrichment_fields": {
            "title": "Enrichment Fields",
            "description": "Fields to copy from matched taxonomy node when enriching (append/replace semantics). If omitted, the full payload is copied.",
            "items": {
              "$ref": "#/components/schemas/EnrichmentField"
            },
            "type": "array",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "collection_id"
        ],
        "title": "SourceCollection",
        "description": "A source collection for a flat taxonomy.",
        "examples": [
          {
            "collection_id": "col_products_v1",
            "enrichment_fields": [
              {
                "field_path": "metadata.tags",
                "merge_mode": "append"
              }
            ],
            "input_mappings": [
              {
                "input_key": "image_vector",
                "path": "features.clip_vit_l_14",
                "source_type": "vector"
              }
            ],
            "retriever_id": "ret_clip_v1"
          }
        ]
      },
      "SourceConfig": {
        "properties": {
          "type": {
            "$ref": "#/components/schemas/SourceType",
            "description": "Type of source (bucket, collection, etc.)"
          },
          "bucket_id": {
            "title": "Bucket Id",
            "description": "ID of the source bucket if type is BUCKET",
            "type": "string",
            "nullable": true
          },
          "collection_id": {
            "title": "Collection Id",
            "description": "ID of the source collection if type is COLLECTION",
            "type": "string",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "type"
        ],
        "title": "SourceConfig",
        "description": "Configuration for specifying the source of a collection."
      },
      "SourceDetails": {
        "properties": {
          "type": {
            "$ref": "#/components/schemas/SourceType",
            "description": "Immediate origin type from which this entity was derived."
          },
          "source_id": {
            "type": "string",
            "title": "Source Id",
            "description": "Identifier of the immediate source entity (e.g., bucket_id, collection_id, taxonomy_id)."
          }
        },
        "type": "object",
        "required": [
          "type",
          "source_id"
        ],
        "title": "SourceDetails",
        "description": "Generic source details for any Qdrant point/document.\n\nKeep this intentionally minimal so specialized models (e.g., DocumentSourceDetails)\ncan extend it with domain-specific fields."
      },
      "SourceType": {
        "type": "string",
        "enum": [
          "bucket",
          "collection",
          "taxonomy",
          "cluster"
        ],
        "title": "SourceType",
        "description": "Generic source types for any Qdrant point/document."
      },
      "SparseVector": {
        "properties": {
          "indices": {
            "items": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "number"
                }
              ]
            },
            "type": "array",
            "title": "Indices",
            "description": "Indices of non-zero elements"
          },
          "values": {
            "items": {
              "type": "number"
            },
            "type": "array",
            "title": "Values",
            "description": "Values of non-zero elements"
          }
        },
        "type": "object",
        "required": [
          "indices",
          "values"
        ],
        "title": "SparseVector",
        "description": "Sparse vector representation with indices and values.\n\nOnly non-zero elements are stored for efficiency.\n\nExample:\n```json\n{\n    \"indices\": [0, 2, 4],\n    \"values\": [0.1, 0.3, 0.5]\n}\n```"
      },
      "SpectralParams": {
        "properties": {
          "n_clusters": {
            "type": "integer",
            "minimum": 2.0,
            "title": "N Clusters",
            "description": "Number of clusters to form",
            "default": 8
          },
          "eigen_solver": {
            "title": "Eigen Solver",
            "description": "The eigenvalue decomposition strategy ('arpack', 'lobpcg', 'amg', or None)",
            "type": "string",
            "nullable": true
          },
          "n_components": {
            "title": "N Components",
            "description": "Number of eigenvectors to use for spectral embedding",
            "type": "integer",
            "minimum": 1.0,
            "nullable": true
          },
          "random_state": {
            "title": "Random State",
            "description": "Random seed for reproducibility",
            "default": 42,
            "type": "integer",
            "nullable": true
          },
          "n_init": {
            "type": "integer",
            "minimum": 1.0,
            "title": "N Init",
            "description": "Number of times k-means will run with different centroid seeds",
            "default": 10
          },
          "gamma": {
            "type": "number",
            "exclusiveMinimum": 0.0,
            "title": "Gamma",
            "description": "Kernel coefficient for rbf, poly, sigmoid, laplacian and chi2 kernels",
            "default": 1.0
          },
          "affinity": {
            "type": "string",
            "title": "Affinity",
            "description": "How to construct the affinity matrix ('nearest_neighbors', 'rbf', 'precomputed', 'precomputed_nearest_neighbors')",
            "default": "rbf"
          },
          "n_neighbors": {
            "type": "integer",
            "minimum": 1.0,
            "title": "N Neighbors",
            "description": "Number of neighbors to use when constructing the affinity matrix using nearest neighbors",
            "default": 10
          },
          "eigen_tol": {
            "type": "number",
            "minimum": 0.0,
            "title": "Eigen Tol",
            "description": "Stopping criterion for eigendecomposition",
            "default": 0.0
          },
          "assign_labels": {
            "type": "string",
            "title": "Assign Labels",
            "description": "Strategy to assign labels in the embedding space ('kmeans' or 'discretize')",
            "default": "kmeans"
          },
          "degree": {
            "type": "number",
            "title": "Degree",
            "description": "Degree of the polynomial kernel. Ignored by other kernels",
            "default": 3
          },
          "coef0": {
            "type": "number",
            "title": "Coef0",
            "description": "Zero coefficient for polynomial and sigmoid kernels",
            "default": 1
          },
          "kernel_params": {
            "title": "Kernel Params",
            "description": "Parameters for the kernel function",
            "additionalProperties": true,
            "type": "object",
            "nullable": true
          },
          "n_jobs": {
            "type": "integer",
            "title": "N Jobs",
            "description": "Number of parallel jobs to run (-1 means using all processors)",
            "default": 1
          },
          "verbose": {
            "type": "boolean",
            "title": "Verbose",
            "description": "Verbosity mode",
            "default": false
          }
        },
        "type": "object",
        "title": "SpectralParams",
        "description": "Parameters for Spectral clustering algorithm."
      },
      "StageInstanceConfig-Input": {
        "properties": {
          "stage_name": {
            "type": "string",
            "title": "Stage Name"
          },
          "version": {
            "type": "string",
            "title": "Version"
          },
          "parameters": {
            "additionalProperties": true,
            "type": "object",
            "title": "Parameters"
          },
          "pre_filters": {
            "description": "Filters to apply to the documents *before* this stage is executed.These filters are combined with any global retriever filters.",
            "$ref": "#/components/schemas/LogicalOperator-Input",
            "nullable": true
          },
          "post_filters": {
            "description": "Filters to apply to the documents *after* this stage is executed.These filters are applied to the results of this stage before passing to the next.",
            "$ref": "#/components/schemas/LogicalOperator-Input",
            "nullable": true
          },
          "stats": {
            "description": "Performance statistics for this stage",
            "$ref": "#/components/schemas/StagePerformance",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "stage_name",
          "version",
          "parameters"
        ],
        "title": "StageInstanceConfig",
        "description": "User-provided configuration for a stage instance in a retriever pipeline.\n\nThis model is used when creating a retriever to define the specific\nparameters for each stage."
      },
      "StageInstanceConfig-Output": {
        "properties": {
          "stage_name": {
            "type": "string",
            "title": "Stage Name"
          },
          "version": {
            "type": "string",
            "title": "Version"
          },
          "parameters": {
            "additionalProperties": true,
            "type": "object",
            "title": "Parameters"
          },
          "pre_filters": {
            "description": "Filters to apply to the documents *before* this stage is executed.These filters are combined with any global retriever filters.",
            "$ref": "#/components/schemas/LogicalOperator-Output",
            "nullable": true
          },
          "post_filters": {
            "description": "Filters to apply to the documents *after* this stage is executed.These filters are applied to the results of this stage before passing to the next.",
            "$ref": "#/components/schemas/LogicalOperator-Output",
            "nullable": true
          },
          "stats": {
            "description": "Performance statistics for this stage",
            "$ref": "#/components/schemas/StagePerformance",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "stage_name",
          "version",
          "parameters"
        ],
        "title": "StageInstanceConfig",
        "description": "User-provided configuration for a stage instance in a retriever pipeline.\n\nThis model is used when creating a retriever to define the specific\nparameters for each stage."
      },
      "StagePerformance": {
        "properties": {
          "avg_execution_ms": {
            "type": "number",
            "title": "Avg Execution Ms",
            "description": "Average execution time in milliseconds",
            "default": 0.0
          },
          "execution_count": {
            "type": "integer",
            "title": "Execution Count",
            "description": "Number of times executed",
            "default": 0
          },
          "error_count": {
            "type": "integer",
            "title": "Error Count",
            "description": "Number of errors encountered",
            "default": 0
          },
          "last_executed_at": {
            "title": "Last Executed At",
            "description": "Last time this stage was executed",
            "type": "string",
            "format": "date-time",
            "nullable": true
          }
        },
        "type": "object",
        "title": "StagePerformance",
        "description": "Performance statistics for a retriever stage."
      },
      "StageResponse": {
        "properties": {
          "stage_name": {
            "type": "string",
            "title": "Stage Name"
          },
          "version": {
            "type": "string",
            "title": "Version"
          },
          "execution_time": {
            "type": "number",
            "title": "Execution Time"
          },
          "results": {
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/DocumentResult"
                },
                {
                  "$ref": "#/components/schemas/GroupedResultItem"
                }
              ]
            },
            "type": "array",
            "title": "Results"
          },
          "metadata": {
            "additionalProperties": true,
            "type": "object",
            "title": "Metadata"
          }
        },
        "type": "object",
        "required": [
          "stage_name",
          "version",
          "execution_time",
          "results"
        ],
        "title": "StageResponse",
        "description": "Standard response format for a single stage in a retriever pipeline.\n\nEach stage execution returns an object of this type, containing the\nexecution time, results, and any additional metadata."
      },
      "StorageStatistics": {
        "properties": {
          "avg_size_bytes": {
            "type": "integer",
            "title": "Avg Size Bytes",
            "description": "Average object size in bytes",
            "default": 0
          },
          "max_size_bytes": {
            "type": "integer",
            "title": "Max Size Bytes",
            "description": "Size of the largest object in bytes",
            "default": 0
          },
          "min_size_bytes": {
            "type": "integer",
            "title": "Min Size Bytes",
            "description": "Size of the smallest object in bytes",
            "default": 0
          }
        },
        "type": "object",
        "title": "StorageStatistics",
        "description": "Statistics about object storage in a bucket."
      },
      "TSNEParams": {
        "properties": {
          "method": {
            "type": "string",
            "const": "tsne",
            "title": "Method",
            "default": "tsne"
          },
          "n_components": {
            "type": "integer",
            "maximum": 256.0,
            "minimum": 2.0,
            "title": "N Components",
            "default": 2
          },
          "random_state": {
            "type": "integer",
            "title": "Random State",
            "default": 42
          },
          "perplexity": {
            "type": "number",
            "exclusiveMinimum": 0.0,
            "title": "Perplexity",
            "default": 30.0
          },
          "learning_rate": {
            "type": "number",
            "exclusiveMinimum": 0.0,
            "title": "Learning Rate",
            "default": 200.0
          }
        },
        "type": "object",
        "title": "TSNEParams"
      },
      "TaskResponse": {
        "properties": {
          "task_id": {
            "type": "string",
            "title": "Task Id",
            "description": "Unique identifier for the task",
            "example": "task_123"
          },
          "task_type": {
            "$ref": "#/components/schemas/TaskType",
            "description": "Type of the task",
            "example": "api_namespaces_create"
          },
          "status": {
            "$ref": "#/components/schemas/TaskStatusEnum",
            "description": "Current status of the task",
            "example": "IN_PROGRESS"
          },
          "inputs": {
            "title": "Inputs",
            "description": "List of input parameters or data for the task",
            "example": [
              "file1.pdf",
              {
                "config": {
                  "key": "value"
                }
              }
            ],
            "items": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "additionalProperties": true,
                  "type": "object"
                }
              ]
            },
            "type": "array",
            "nullable": true
          },
          "outputs": {
            "title": "Outputs",
            "description": "List of output results from the task",
            "example": [
              "processed_file1.pdf",
              {
                "result": "success"
              }
            ],
            "items": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "additionalProperties": true,
                  "type": "object"
                }
              ]
            },
            "type": "array",
            "nullable": true
          },
          "additional_data": {
            "title": "Additional Data",
            "description": "Additional metadata or context for the task",
            "example": {
              "priority": "high",
              "user_id": "user_456"
            },
            "additionalProperties": true,
            "type": "object",
            "nullable": true
          },
          "error_message": {
            "title": "Error Message",
            "description": "Flattened error message derived from additional_data['error'] if present.",
            "type": "string",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "task_id",
          "task_type",
          "status"
        ],
        "title": "TaskResponse",
        "description": "Task response."
      },
      "TaskStatusEnum": {
        "type": "string",
        "enum": [
          "PENDING",
          "IN_PROGRESS",
          "PROCESSING",
          "COMPLETED",
          "FAILED",
          "CANCELED",
          "UNKNOWN",
          "SKIPPED",
          "DRAFT",
          "ACTIVE",
          "ARCHIVED",
          "SUSPENDED"
        ],
        "title": "TaskStatusEnum",
        "description": "Enumeration of task statuses."
      },
      "TaskType": {
        "type": "string",
        "enum": [
          "api_namespaces_create",
          "api_buckets_objects_create",
          "api_buckets_delete",
          "api_buckets_batches_process",
          "api_buckets_batches_submit",
          "api_taxonomies_create",
          "api_taxonomies_execute",
          "api_taxonomies_materialize",
          "engine_feature_extractor_run",
          "engine_inference_run",
          "engine_object_processing",
          "engine_cluster_build",
          "thumbnail",
          "materialize"
        ],
        "title": "TaskType",
        "description": "Types of tasks that can be performed in the system."
      },
      "TaxonomyApplicationConfig": {
        "properties": {
          "taxonomy_id": {
            "type": "string",
            "title": "Taxonomy Id",
            "description": "ID of the `TaxonomyModel` to execute."
          },
          "execution_mode": {
            "$ref": "#/components/schemas/TaxonomyExecutionMode",
            "description": "'on_demand' executes at query time; 'materialize' materialises during ingestion.",
            "default": "on_demand"
          },
          "target_collection_id": {
            "title": "Target Collection Id",
            "description": "Optional collection to persist results into when `execution_mode` is 'materialize'. If omitted, the source collection is updated in-place.",
            "type": "string",
            "nullable": true
          },
          "scroll_filters": {
            "description": "Additional filters applied when scrolling the source collection before enrichment.",
            "$ref": "#/components/schemas/LogicalOperator-Output",
            "nullable": true
          }
        },
        "additionalProperties": false,
        "type": "object",
        "required": [
          "taxonomy_id"
        ],
        "title": "TaxonomyApplicationConfig",
        "description": "Configuration block that attaches a taxonomy to a collection.",
        "examples": [
          {
            "execution_mode": "on_demand",
            "taxonomy_id": "tax_abc123"
          },
          {
            "execution_mode": "materialize",
            "target_collection_id": "col_enriched_v1",
            "taxonomy_id": "tax_abc123"
          }
        ]
      },
      "TaxonomyAssignment": {
        "properties": {
          "taxonomy_id": {
            "type": "string",
            "title": "Taxonomy Id",
            "description": "ID of the taxonomy"
          },
          "node_id": {
            "type": "string",
            "title": "Node Id",
            "description": "Matched taxonomy node ID"
          },
          "path": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Path",
            "description": "Optional hierarchical path labels"
          },
          "label": {
            "title": "Label",
            "description": "Optional human-readable label",
            "type": "string",
            "nullable": true
          },
          "score": {
            "title": "Score",
            "description": "Optional similarity score",
            "type": "number",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "taxonomy_id",
          "node_id"
        ],
        "title": "TaxonomyAssignment",
        "description": "Represents a taxonomy node assignment for a document.\n\nThis is a lightweight reference to a taxonomy/node with optional\npath/label/score metadata; full node details live in the taxonomy module.",
        "examples": [
          {
            "label": "Mobile Phones",
            "node_id": "node_electronics_phones",
            "path": [
              "products",
              "electronics",
              "phones"
            ],
            "score": 0.87,
            "taxonomy_id": "tax_products"
          }
        ]
      },
      "TaxonomyExecutionMode": {
        "type": "string",
        "enum": [
          "on_demand",
          "materialize"
        ],
        "title": "TaxonomyExecutionMode",
        "description": "How a taxonomy should be executed when attached to a collection."
      },
      "TaxonomyModel": {
        "properties": {
          "taxonomy_id": {
            "type": "string",
            "title": "Taxonomy Id",
            "description": "Unique identifier for the taxonomy"
          },
          "version": {
            "type": "integer",
            "minimum": 1.0,
            "title": "Version",
            "description": "Monotonic version number of the taxonomy configuration",
            "default": 1
          },
          "taxonomy_name": {
            "type": "string",
            "title": "Taxonomy Name",
            "description": "A unique name for the taxonomy within the namespace."
          },
          "description": {
            "title": "Description",
            "description": "Optional human-readable description.",
            "type": "string",
            "nullable": true
          },
          "retriever_id": {
            "title": "Retriever Id",
            "description": "Optional taxonomy-level retriever (prefer per-layer).",
            "type": "string",
            "nullable": true
          },
          "input_mappings": {
            "title": "Input Mappings",
            "description": "Optional taxonomy-level inputs (prefer per-layer).",
            "items": {
              "$ref": "#/components/schemas/InputMapping"
            },
            "type": "array",
            "nullable": true
          },
          "config": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/FlatTaxonomyConfig-Input"
              },
              {
                "$ref": "#/components/schemas/HierarchicalTaxonomyConfig-Input"
              }
            ],
            "title": "Config",
            "description": "Configuration specific to the taxonomy type."
          },
          "ready": {
            "type": "boolean",
            "title": "Ready",
            "description": "Whether the taxonomy is ready for use. False for async inference (cluster/LLM) that needs processing. True for flat/explicit hierarchies.",
            "default": true
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At",
            "description": "Creation timestamp for this taxonomy record"
          }
        },
        "type": "object",
        "required": [
          "taxonomy_name",
          "config"
        ],
        "title": "TaxonomyModel",
        "description": "Primary Pydantic model representing a taxonomy definition.",
        "examples": [
          {
            "config": {
              "default_input_mappings": [
                {
                  "input_key": "image_vector",
                  "path": "features.clip_vit_l_14",
                  "source_type": "vector"
                }
              ],
              "default_retriever_id": "ret_clip_v1",
              "source_collection": {
                "collection_id": "col_products_v1"
              },
              "taxonomy_type": "flat"
            },
            "namespace_id": "ns_123",
            "taxonomy_name": "product_tags",
            "taxonomy_type": "flat"
          },
          {
            "config": {
              "build_mode": "explicit",
              "default_input_mappings": [
                {
                  "input_key": "face_vec",
                  "path": "features.face",
                  "source_type": "vector"
                }
              ],
              "default_retriever_id": "ret_face_v1",
              "hierarchical_nodes": [
                {
                  "collection_id": "col_employees_v1"
                },
                {
                  "collection_id": "col_executives_v1",
                  "parent_collection_id": "col_employees_v1"
                }
              ],
              "taxonomy_type": "hierarchical"
            },
            "namespace_id": "ns_123",
            "taxonomy_name": "org_hierarchy",
            "taxonomy_type": "hierarchical"
          }
        ]
      },
      "TaxonomyResponse": {
        "properties": {
          "taxonomy_id": {
            "type": "string",
            "title": "Taxonomy Id",
            "description": "Unique identifier for the taxonomy"
          },
          "version": {
            "type": "integer",
            "minimum": 1.0,
            "title": "Version",
            "description": "Monotonic version number of the taxonomy configuration",
            "default": 1
          },
          "taxonomy_name": {
            "type": "string",
            "title": "Taxonomy Name",
            "description": "A unique name for the taxonomy within the namespace."
          },
          "description": {
            "title": "Description",
            "description": "Optional human-readable description.",
            "type": "string",
            "nullable": true
          },
          "retriever_id": {
            "title": "Retriever Id",
            "description": "Optional taxonomy-level retriever (prefer per-layer).",
            "type": "string",
            "nullable": true
          },
          "input_mappings": {
            "title": "Input Mappings",
            "description": "Optional taxonomy-level inputs (prefer per-layer).",
            "items": {
              "$ref": "#/components/schemas/InputMapping"
            },
            "type": "array",
            "nullable": true
          },
          "config": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/FlatTaxonomyConfig-Output"
              },
              {
                "$ref": "#/components/schemas/HierarchicalTaxonomyConfig-Output"
              }
            ],
            "title": "Config",
            "description": "Configuration specific to the taxonomy type."
          },
          "ready": {
            "type": "boolean",
            "title": "Ready",
            "description": "Whether the taxonomy is ready for use. False for async inference (cluster/LLM) that needs processing. True for flat/explicit hierarchies.",
            "default": true
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At",
            "description": "Creation timestamp for this taxonomy record"
          }
        },
        "type": "object",
        "required": [
          "taxonomy_name",
          "config"
        ],
        "title": "TaxonomyResponse",
        "description": "Response model for a taxonomy.",
        "examples": [
          {
            "config": {
              "default_input_mappings": [
                {
                  "input_key": "image_vector",
                  "path": "features.clip_vit_l_14",
                  "source_type": "vector"
                }
              ],
              "default_retriever_id": "ret_clip_v1",
              "source_collection": {
                "collection_id": "col_products_v1"
              },
              "taxonomy_type": "flat"
            },
            "namespace_id": "ns_123",
            "taxonomy_name": "product_tags",
            "taxonomy_type": "flat"
          },
          {
            "config": {
              "build_mode": "explicit",
              "default_input_mappings": [
                {
                  "input_key": "face_vec",
                  "path": "features.face",
                  "source_type": "vector"
                }
              ],
              "default_retriever_id": "ret_face_v1",
              "hierarchical_nodes": [
                {
                  "collection_id": "col_employees_v1"
                },
                {
                  "collection_id": "col_executives_v1",
                  "parent_collection_id": "col_employees_v1"
                }
              ],
              "taxonomy_type": "hierarchical"
            },
            "namespace_id": "ns_123",
            "taxonomy_name": "org_hierarchy",
            "taxonomy_type": "hierarchical"
          }
        ]
      },
      "TextIndexParams": {
        "properties": {
          "type": {
            "type": "string",
            "title": "Type",
            "default": "text"
          },
          "tokenizer": {
            "$ref": "#/components/schemas/TokenizerType",
            "default": "word"
          },
          "min_token_len": {
            "type": "integer",
            "title": "Min Token Len",
            "default": 2
          },
          "max_token_len": {
            "type": "integer",
            "title": "Max Token Len",
            "default": 15
          },
          "lowercase": {
            "type": "boolean",
            "title": "Lowercase",
            "default": true
          }
        },
        "type": "object",
        "title": "TextIndexParams",
        "description": "Configuration for text index."
      },
      "TokenizerType": {
        "type": "string",
        "enum": [
          "word",
          "whitespace",
          "prefix",
          "multilingual"
        ],
        "title": "TokenizerType",
        "description": "Tokenizer type."
      },
      "TriggerExecutionConfig": {
        "properties": {
          "collection_ids": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Collection Ids",
            "description": "Collections to cluster"
          },
          "config": {
            "additionalProperties": true,
            "type": "object",
            "title": "Config",
            "description": "ClusteringConfig as dict"
          }
        },
        "type": "object",
        "required": [
          "collection_ids",
          "config"
        ],
        "title": "TriggerExecutionConfig",
        "description": "Configuration for cluster execution when trigger fires."
      },
      "TriggerExecutionHistoryItem": {
        "properties": {
          "job_id": {
            "type": "string",
            "title": "Job Id",
            "description": "Job ID"
          },
          "triggered_at": {
            "type": "string",
            "format": "date-time",
            "title": "Triggered At",
            "description": "When trigger fired"
          },
          "status": {
            "type": "string",
            "title": "Status",
            "description": "Execution status"
          },
          "execution_time_ms": {
            "title": "Execution Time Ms",
            "description": "Execution time in milliseconds",
            "type": "integer",
            "nullable": true
          },
          "error": {
            "title": "Error",
            "description": "Error message if failed",
            "type": "string",
            "nullable": true
          },
          "num_clusters": {
            "title": "Num Clusters",
            "description": "Number of clusters created",
            "type": "integer",
            "nullable": true
          },
          "num_documents": {
            "title": "Num Documents",
            "description": "Number of documents processed",
            "type": "integer",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "job_id",
          "triggered_at",
          "status"
        ],
        "title": "TriggerExecutionHistoryItem",
        "description": "Single execution history item."
      },
      "TriggerHistoryRequest": {
        "properties": {
          "offset": {
            "type": "integer",
            "minimum": 0.0,
            "title": "Offset",
            "description": "Pagination offset",
            "default": 0
          },
          "limit": {
            "type": "integer",
            "maximum": 1000.0,
            "minimum": 1.0,
            "title": "Limit",
            "description": "Results per page",
            "default": 50
          },
          "status_filter": {
            "title": "Status Filter",
            "description": "Filter by execution status",
            "type": "string",
            "nullable": true
          }
        },
        "type": "object",
        "title": "TriggerHistoryRequest",
        "description": "Request for trigger execution history."
      },
      "TriggerHistoryResponse": {
        "properties": {
          "trigger_id": {
            "type": "string",
            "title": "Trigger Id",
            "description": "Trigger ID"
          },
          "executions": {
            "items": {
              "$ref": "#/components/schemas/TriggerExecutionHistoryItem"
            },
            "type": "array",
            "title": "Executions",
            "description": "Execution history"
          },
          "total": {
            "type": "integer",
            "title": "Total",
            "description": "Total executions"
          },
          "offset": {
            "type": "integer",
            "title": "Offset",
            "description": "Current offset"
          },
          "limit": {
            "type": "integer",
            "title": "Limit",
            "description": "Current limit"
          }
        },
        "type": "object",
        "required": [
          "trigger_id",
          "executions",
          "total",
          "offset",
          "limit"
        ],
        "title": "TriggerHistoryResponse",
        "description": "Response for trigger execution history."
      },
      "TriggerModel": {
        "properties": {
          "trigger_id": {
            "type": "string",
            "title": "Trigger Id",
            "description": "Unique trigger ID"
          },
          "cluster_id": {
            "title": "Cluster Id",
            "description": "Optional link to cluster definition",
            "type": "string",
            "nullable": true
          },
          "namespace_id": {
            "type": "string",
            "title": "Namespace Id",
            "description": "Namespace ID"
          },
          "internal_id": {
            "type": "string",
            "title": "Internal Id",
            "description": "Organization internal ID"
          },
          "execution_config": {
            "$ref": "#/components/schemas/TriggerExecutionConfig",
            "description": "Configuration for cluster execution"
          },
          "trigger_type": {
            "$ref": "#/components/schemas/TriggerType",
            "description": "Type of trigger"
          },
          "schedule_config": {
            "additionalProperties": true,
            "type": "object",
            "title": "Schedule Config",
            "description": "Type-specific schedule configuration"
          },
          "status": {
            "$ref": "#/components/schemas/TriggerStatus",
            "description": "Current status",
            "default": "active"
          },
          "last_triggered_at": {
            "title": "Last Triggered At",
            "description": "Last time trigger fired",
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "last_execution_job_id": {
            "title": "Last Execution Job Id",
            "description": "Job ID of last execution",
            "type": "string",
            "nullable": true
          },
          "next_scheduled_at": {
            "title": "Next Scheduled At",
            "description": "Next scheduled execution time",
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "execution_count": {
            "type": "integer",
            "title": "Execution Count",
            "description": "Total executions",
            "default": 0
          },
          "consecutive_failures": {
            "type": "integer",
            "title": "Consecutive Failures",
            "description": "Consecutive execution failures",
            "default": 0
          },
          "last_execution_status": {
            "title": "Last Execution Status",
            "description": "Status of last execution",
            "type": "string",
            "nullable": true
          },
          "last_execution_error": {
            "title": "Last Execution Error",
            "description": "Error from last execution",
            "type": "string",
            "nullable": true
          },
          "event_counter": {
            "type": "integer",
            "title": "Event Counter",
            "description": "Current event count since last trigger",
            "default": 0
          },
          "last_cooldown_at": {
            "title": "Last Cooldown At",
            "description": "Last time cooldown was applied",
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At",
            "description": "Creation timestamp"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Updated At",
            "description": "Last update timestamp"
          },
          "created_by": {
            "title": "Created By",
            "description": "User who created trigger",
            "type": "string",
            "nullable": true
          },
          "description": {
            "title": "Description",
            "description": "Trigger description",
            "type": "string",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "namespace_id",
          "internal_id",
          "execution_config",
          "trigger_type",
          "schedule_config"
        ],
        "title": "TriggerModel",
        "description": "Model for cluster trigger."
      },
      "TriggerStatus": {
        "type": "string",
        "enum": [
          "active",
          "paused",
          "disabled",
          "failed"
        ],
        "title": "TriggerStatus",
        "description": "Status of a cluster trigger."
      },
      "TriggerType": {
        "type": "string",
        "enum": [
          "cron",
          "interval",
          "event",
          "conditional"
        ],
        "title": "TriggerType",
        "description": "Type of trigger for cluster execution."
      },
      "UMAPParams": {
        "properties": {
          "method": {
            "type": "string",
            "const": "umap",
            "title": "Method",
            "default": "umap"
          },
          "n_components": {
            "type": "integer",
            "maximum": 256.0,
            "minimum": 2.0,
            "title": "N Components",
            "default": 2
          },
          "random_state": {
            "type": "integer",
            "title": "Random State",
            "default": 42
          },
          "n_neighbors": {
            "type": "integer",
            "minimum": 2.0,
            "title": "N Neighbors",
            "default": 15
          },
          "min_dist": {
            "type": "number",
            "maximum": 1.0,
            "minimum": 0.0,
            "title": "Min Dist",
            "default": 0.1
          }
        },
        "type": "object",
        "title": "UMAPParams"
      },
      "UpdateNamespaceRequest": {
        "properties": {
          "namespace_name": {
            "title": "Namespace Name",
            "description": "Name of the namespace to update",
            "example": "spotify_playlists_dev",
            "type": "string",
            "nullable": true
          },
          "payload_indexes": {
            "title": "Payload Indexes",
            "description": "Updated list of payload index configurations",
            "example": [
              {
                "field_name": "metadata.title",
                "field_schema": {
                  "lowercase": true,
                  "max_token_len": 15,
                  "min_token_len": 2,
                  "tokenizer": "word",
                  "type": "text"
                },
                "type": "text"
              },
              {
                "field_name": "metadata.description",
                "field_schema": {
                  "is_tenant": false,
                  "type": "keyword"
                },
                "type": "keyword"
              }
            ],
            "items": {
              "$ref": "#/components/schemas/PayloadIndexConfig-Input"
            },
            "type": "array",
            "nullable": true
          }
        },
        "type": "object",
        "title": "UpdateNamespaceRequest",
        "description": "Request schema for updating a namespace's payload indexes."
      },
      "UpdateObjectRequest": {
        "properties": {
          "key_prefix": {
            "title": "Key Prefix",
            "description": "Updated storage key/path prefix of the object, this will be used to retrieve the object from the storage. It's at the root of the object.",
            "type": "string",
            "nullable": true
          },
          "blobs": {
            "title": "Blobs",
            "description": "List of new or updated blobs for this object",
            "items": {
              "$ref": "#/components/schemas/CreateBlobRequest"
            },
            "type": "array",
            "nullable": true
          },
          "metadata": {
            "title": "Metadata",
            "description": "Updated metadata for the object, this will be merged with existing metadata.",
            "additionalProperties": true,
            "type": "object",
            "nullable": true
          },
          "skip_duplicates": {
            "title": "Skip Duplicates",
            "description": "Skip duplicate blobs, if a blob with the same hash already exists, it will be skipped.",
            "type": "boolean",
            "nullable": true
          }
        },
        "type": "object",
        "title": "UpdateObjectRequest",
        "description": "Request model for updating an existing bucket object."
      },
      "UpdateTriggerRequest": {
        "properties": {
          "schedule_config": {
            "title": "Schedule Config",
            "description": "Updated schedule configuration",
            "additionalProperties": true,
            "type": "object",
            "nullable": true
          },
          "description": {
            "title": "Description",
            "description": "Updated description",
            "type": "string",
            "nullable": true
          },
          "status": {
            "description": "Updated status",
            "$ref": "#/components/schemas/TriggerStatus",
            "nullable": true
          }
        },
        "type": "object",
        "title": "UpdateTriggerRequest",
        "description": "Request to update an existing trigger."
      },
      "UsageStatistics": {
        "properties": {
          "total_queries": {
            "type": "integer",
            "title": "Total Queries",
            "description": "Total number of queries executed",
            "default": 0
          },
          "queries_last_24h": {
            "type": "integer",
            "title": "Queries Last 24H",
            "description": "Number of queries in the last 24 hours",
            "default": 0
          },
          "avg_latency_ms": {
            "type": "number",
            "title": "Avg Latency Ms",
            "description": "Average latency in milliseconds",
            "default": 0.0
          },
          "error_rate": {
            "type": "number",
            "maximum": 1.0,
            "minimum": 0.0,
            "title": "Error Rate",
            "description": "Error rate as a fraction (0.0 - 1.0)",
            "default": 0.0
          },
          "last_error": {
            "title": "Last Error",
            "description": "Most recent error message for debugging",
            "type": "string",
            "nullable": true
          },
          "cache_hit_rate": {
            "title": "Cache Hit Rate",
            "description": "Cache hit rate if caching is enabled (0.0 - 1.0)",
            "type": "number",
            "maximum": 1.0,
            "minimum": 0.0,
            "nullable": true
          }
        },
        "type": "object",
        "title": "UsageStatistics",
        "description": "Usage statistics for a retriever."
      },
      "UserModel-Input": {
        "properties": {
          "user_id": {
            "type": "string",
            "title": "User Id"
          },
          "user_name": {
            "type": "string",
            "title": "User Name"
          },
          "email": {
            "type": "string",
            "format": "email",
            "title": "Email"
          },
          "api_keys": {
            "items": {
              "$ref": "#/components/schemas/APIKey"
            },
            "type": "array",
            "title": "Api Keys"
          },
          "metadata": {
            "additionalProperties": true,
            "type": "object",
            "title": "Metadata"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At"
          }
        },
        "type": "object",
        "required": [
          "email"
        ],
        "title": "UserModel",
        "description": "User Model."
      },
      "UserModel-Output": {
        "properties": {
          "user_id": {
            "type": "string",
            "title": "User Id"
          },
          "user_name": {
            "type": "string",
            "title": "User Name"
          },
          "email": {
            "type": "string",
            "format": "email",
            "title": "Email"
          },
          "api_keys": {
            "items": {
              "$ref": "#/components/schemas/APIKey"
            },
            "type": "array",
            "title": "Api Keys"
          },
          "metadata": {
            "additionalProperties": true,
            "type": "object",
            "title": "Metadata"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At"
          }
        },
        "type": "object",
        "required": [
          "email"
        ],
        "title": "UserModel",
        "description": "User Model."
      },
      "UuidIndexParams": {
        "properties": {
          "type": {
            "type": "string",
            "title": "Type",
            "default": "uuid"
          },
          "is_tenant": {
            "type": "boolean",
            "title": "Is Tenant",
            "default": false
          }
        },
        "type": "object",
        "title": "UuidIndexParams",
        "description": "Configuration for UUID index."
      },
      "ValidationError": {
        "properties": {
          "loc": {
            "items": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ]
            },
            "type": "array",
            "title": "Location"
          },
          "msg": {
            "type": "string",
            "title": "Message"
          },
          "type": {
            "type": "string",
            "title": "Error Type"
          }
        },
        "type": "object",
        "required": [
          "loc",
          "msg",
          "type"
        ],
        "title": "ValidationError"
      },
      "VectorBasedConfig": {
        "properties": {
          "feature_extractor_name": {
            "type": "string",
            "title": "Feature Extractor Name",
            "description": "Name of the feature extractor to use for vectors"
          },
          "clustering_method": {
            "$ref": "#/components/schemas/ClusteringAlgorithm",
            "description": "Clustering algorithm to use"
          },
          "sample_size": {
            "title": "Sample Size",
            "description": "Number of samples to use for clustering",
            "type": "integer",
            "nullable": true
          },
          "kmeans_parameters": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/KMeansParams"
              },
              {
                "additionalProperties": true,
                "type": "object"
              }
            ],
            "title": "Kmeans Parameters",
            "description": "Parameters for K-means clustering (deprecated, use algorithm_params)",
            "nullable": true
          },
          "dbscan_parameters": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/DBSCANParams"
              },
              {
                "additionalProperties": true,
                "type": "object"
              }
            ],
            "title": "Dbscan Parameters",
            "description": "Parameters for DBSCAN clustering (deprecated, use algorithm_params)",
            "nullable": true
          },
          "hdbscan_parameters": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/HDBSCANParams"
              },
              {
                "additionalProperties": true,
                "type": "object"
              }
            ],
            "title": "Hdbscan Parameters",
            "description": "Parameters for HDBSCAN clustering (deprecated, use algorithm_params)",
            "nullable": true
          },
          "algorithm_params": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/KMeansParams"
              },
              {
                "$ref": "#/components/schemas/DBSCANParams"
              },
              {
                "$ref": "#/components/schemas/HDBSCANParams"
              },
              {
                "$ref": "#/components/schemas/AgglomerativeParams"
              },
              {
                "$ref": "#/components/schemas/SpectralParams"
              },
              {
                "$ref": "#/components/schemas/GaussianMixtureParams"
              },
              {
                "$ref": "#/components/schemas/MeanShiftParams"
              },
              {
                "$ref": "#/components/schemas/OPTICSParams"
              },
              {
                "additionalProperties": true,
                "type": "object"
              }
            ],
            "title": "Algorithm Params",
            "description": "Algorithm-specific parameters",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "feature_extractor_name",
          "clustering_method"
        ],
        "title": "VectorBasedConfig",
        "description": "Configuration for vector-based clustering."
      },
      "VectorDataType": {
        "type": "string",
        "enum": [
          "float32",
          "uint8"
        ],
        "title": "VectorDataType",
        "description": "Vector data type."
      },
      "VectorIndex": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Name"
          },
          "description": {
            "type": "string",
            "title": "Description"
          },
          "dimensions": {
            "type": "integer",
            "title": "Dimensions"
          },
          "type": {
            "$ref": "#/components/schemas/VectorType"
          },
          "distance": {
            "title": "Distance",
            "default": "cosine",
            "type": "string",
            "nullable": true
          },
          "datatype": {
            "description": "Data type of the vector.",
            "default": "float32",
            "$ref": "#/components/schemas/VectorDataType",
            "nullable": true
          },
          "on_disk": {
            "title": "On Disk",
            "description": "If true, vectors will be stored on disk. Use for large vectors.",
            "type": "boolean",
            "nullable": true
          },
          "supported_inputs": {
            "title": "Supported Inputs",
            "items": {
              "$ref": "#/components/schemas/BucketSchemaFieldType"
            },
            "type": "array",
            "nullable": true
          },
          "inference_name": {
            "title": "Inference Name",
            "description": "The path to the embedding model service to use for this vector index.",
            "type": "string",
            "nullable": true
          }
        },
        "type": "object",
        "required": [
          "name",
          "description",
          "dimensions",
          "type"
        ],
        "title": "VectorIndex",
        "description": "Base configuration for vector indexes."
      },
      "VectorIndexDefinition": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Name"
          },
          "description": {
            "type": "string",
            "title": "Description"
          },
          "type": {
            "type": "string",
            "enum": [
              "single",
              "multi"
            ],
            "title": "Type"
          },
          "index": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/VectorIndex"
              },
              {
                "$ref": "#/components/schemas/MultiVectorIndex"
              }
            ],
            "title": "Index"
          }
        },
        "type": "object",
        "required": [
          "name",
          "description",
          "type",
          "index"
        ],
        "title": "VectorIndexDefinition",
        "description": "Complete vector index definition that can be either single or multi-vector."
      },
      "VectorType": {
        "type": "string",
        "enum": [
          "dense",
          "sparse",
          "multi_dense"
        ],
        "title": "VectorType",
        "description": "Enumeration of vector types supported by the system."
      },
      "Webhook-Input": {
        "properties": {
          "webhook_id": {
            "type": "string",
            "title": "Webhook Id",
            "description": "Unique identifier for the webhook."
          },
          "webhook_name": {
            "type": "string",
            "title": "Webhook Name",
            "description": "Human-readable name for the webhook."
          },
          "internal_id": {
            "title": "Internal Id",
            "description": "The internal ID of the organization that owns this webhook.",
            "type": "string",
            "nullable": true
          },
          "event_types": {
            "items": {
              "$ref": "#/components/schemas/WebhookEventType"
            },
            "type": "array",
            "title": "Event Types",
            "description": "A list of event types that this webhook subscribes to."
          },
          "channels": {
            "items": {
              "$ref": "#/components/schemas/WebhookChannel-Input"
            },
            "type": "array",
            "title": "Channels",
            "description": "A list of channels to notify for the subscribed events."
          },
          "is_active": {
            "type": "boolean",
            "title": "Is Active",
            "description": "Whether the webhook is currently active and should send notifications.",
            "default": true
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At",
            "description": "Timestamp of when the webhook was created."
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Updated At",
            "description": "Timestamp of the last update."
          }
        },
        "type": "object",
        "required": [
          "webhook_name",
          "event_types",
          "channels"
        ],
        "title": "Webhook",
        "description": "Represents a configured webhook for an organization."
      },
      "Webhook-Output": {
        "properties": {
          "webhook_id": {
            "type": "string",
            "title": "Webhook Id",
            "description": "Unique identifier for the webhook."
          },
          "webhook_name": {
            "type": "string",
            "title": "Webhook Name",
            "description": "Human-readable name for the webhook."
          },
          "event_types": {
            "items": {
              "$ref": "#/components/schemas/WebhookEventType"
            },
            "type": "array",
            "title": "Event Types",
            "description": "A list of event types that this webhook subscribes to."
          },
          "channels": {
            "items": {
              "$ref": "#/components/schemas/WebhookChannel-Output"
            },
            "type": "array",
            "title": "Channels",
            "description": "A list of channels to notify for the subscribed events."
          },
          "is_active": {
            "type": "boolean",
            "title": "Is Active",
            "description": "Whether the webhook is currently active and should send notifications.",
            "default": true
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At",
            "description": "Timestamp of when the webhook was created."
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Updated At",
            "description": "Timestamp of the last update."
          }
        },
        "type": "object",
        "required": [
          "webhook_name",
          "event_types",
          "channels"
        ],
        "title": "Webhook",
        "description": "Represents a configured webhook for an organization."
      },
      "WebhookChannel-Input": {
        "properties": {
          "channel": {
            "$ref": "#/components/schemas/NotificationChannel",
            "description": "The channel through which notifications are sent."
          },
          "configs": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/EmailConfig"
              },
              {
                "$ref": "#/components/schemas/SlackConfig"
              },
              {
                "$ref": "#/components/schemas/WebhookConfig"
              },
              {
                "$ref": "#/components/schemas/SmsConfig"
              }
            ],
            "title": "Configs",
            "description": "Configuration for the selected channel."
          }
        },
        "type": "object",
        "required": [
          "channel",
          "configs"
        ],
        "title": "WebhookChannel",
        "description": "Model for a single notification channel configuration within a webhook."
      },
      "WebhookChannel-Output": {
        "properties": {
          "channel": {
            "$ref": "#/components/schemas/NotificationChannel",
            "description": "The channel through which notifications are sent."
          },
          "configs": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/EmailConfig"
              },
              {
                "$ref": "#/components/schemas/SlackConfig"
              },
              {
                "$ref": "#/components/schemas/WebhookConfig"
              },
              {
                "$ref": "#/components/schemas/SmsConfig"
              }
            ],
            "title": "Configs",
            "description": "Configuration for the selected channel."
          }
        },
        "type": "object",
        "required": [
          "channel",
          "configs"
        ],
        "title": "WebhookChannel",
        "description": "Model for a single notification channel configuration within a webhook."
      },
      "WebhookConfig": {
        "properties": {
          "url": {
            "type": "string",
            "title": "Url",
            "description": "The URL to which the webhook will be sent."
          },
          "headers": {
            "additionalProperties": {
              "type": "string"
            },
            "type": "object",
            "title": "Headers",
            "description": "Custom headers to include in the webhook request."
          },
          "payload_template": {
            "title": "Payload Template",
            "description": "A Jinja2 template for the JSON payload.",
            "additionalProperties": true,
            "type": "object",
            "nullable": true
          },
          "timeout": {
            "type": "number",
            "title": "Timeout",
            "description": "Request timeout in seconds.",
            "default": 10.0
          }
        },
        "type": "object",
        "required": [
          "url"
        ],
        "title": "WebhookConfig",
        "description": "Configuration for webhook notifications."
      },
      "WebhookEventType": {
        "type": "string",
        "enum": [
          "object.created",
          "object.updated",
          "object.deleted",
          "collection.created",
          "collection.updated",
          "collection.deleted",
          "cluster.created",
          "cluster.updated",
          "cluster.deleted",
          "cluster.execution.started",
          "cluster.execution.completed",
          "cluster.execution.failed",
          "trigger.created",
          "trigger.updated",
          "trigger.deleted",
          "trigger.paused",
          "trigger.resumed",
          "trigger.fired",
          "trigger.execution.completed",
          "trigger.execution.failed",
          "taxonomy.created"
        ],
        "title": "WebhookEventType",
        "description": "Enum for webhook event types.\n\nEach event type includes a comment indicating cache invalidation scope:\n- [KEY] = Invalidate specific document keys\n- [COLLECTION] = Invalidate collection-level cache\n- [NAMESPACE] = Invalidate namespace-level cache"
      },
      "api__health__HealthStatus": {
        "type": "string",
        "enum": [
          "OK",
          "DEGRADED"
        ],
        "title": "HealthStatus",
        "description": "Overall health status."
      },
      "shared__retrievers__models__HealthStatus": {
        "type": "string",
        "enum": [
          "healthy",
          "degraded",
          "unhealthy"
        ],
        "title": "HealthStatus",
        "description": "Health status of a retriever."
      }
    }
  }
}